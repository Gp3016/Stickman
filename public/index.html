<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #90EE90 50%, #7CFC00 100%);
            border: 3px solid #333;
            border-radius: 10px;
            display: block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: white;
        }
        
        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .health-bar {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.1s ease;
            border-radius: 13px;
        }
        
        .health-fill.player {
            background: linear-gradient(90deg, #44ff44, #66ff66);
        }
        
        .health-fill.player2 {
            background: linear-gradient(90deg, #4444ff, #6666ff);
        }
        
        .charge-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .charge-bar {
            width: 150px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        .charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ffdd00);
            transition: width 0.2s ease;
            border-radius: 8px;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
            color: white;
            font-size: 14px;
        }
        
        .controls h3 {
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .control-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 5px 0;
        }
        
        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-weight: bold;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }
        
        .game-over h2 {
            font-size: 36px;
            margin-bottom: 15px;
        }
        
        .game-over button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .game-over button:hover {
            transform: scale(1.05);
        }
        
        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
        }
        
        .start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .coin-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            font-size: 24px;
            color: #ffd700;
        }
        
        .coin-icon {
            width: 30px;
            height: 30px;
            background: #ffd700;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .coin-icon::before {
            content: "$";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
        }
        
        .start-screen button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 20px;
        }
        
        .start-screen button:hover {
            transform: scale(1.05);
        }
        
        .character-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .character-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .character-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .character-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .character-card.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.3);
        }
        
        .character-card.locked {
            background: rgba(50, 50, 50, 0.3);
            border-color: #555;
            cursor: not-allowed;
        }
        
        .character-card.locked:hover {
            transform: none;
        }
        
        .lock-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
        }
        
        .lock-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .unlock-cost {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 18px;
            color: #ffd700;
        }
        
        .small-coin {
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            display: inline-block;
            position: relative;
        }
        
        .small-coin::before {
            content: "$";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
            font-size: 12px;
        }
        
        .character-preview {
            width: 100px;
            height: 120px;
            margin: 0 auto 15px;
            position: relative;
        }
        
        .character-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .character-stats {
            font-size: 14px;
            line-height: 1.6;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stat-bar {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-left: 10px;
        }
        
        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #44ff44, #66ff66);
            border-radius: 4px;
        }
        
        .start-button-container {
            margin-top: 30px;
            text-align: center;
        }
        
        #startGameBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin: 0 auto;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #startGameBtn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        #startGameBtn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .selection-instruction {
            margin-bottom: 20px;
            font-size: 18px;
            color: #ccc;
        }
        
        .mode-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 600px;
        }
        
        .mode-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .mode-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 30px;
            font-size: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .mode-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .mode-description {
            margin-top: 20px;
            font-size: 16px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .special-attack-info {
            margin-top: 10px;
            font-size: 12px;
            color: #ffaa00;
        }
        
        .difficulty-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 500px;
        }
        
        .difficulty-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .difficulty-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .difficulty-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .difficulty-description {
            margin-top: 20px;
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .online-lobby {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 500px;
        }
        
        .online-lobby h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .lobby-status {
            font-size: 18px;
            margin-bottom: 20px;
            color: #ccc;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .cancel-button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        
        .cancel-button:hover {
            background: #ff6666;
            transform: scale(1.05);
        }
        
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .connected {
            background: #44ff44;
            color: #000;
        }
        
        .disconnected {
            background: #ff4444;
            color: #fff;
        }
        
        .player2-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }
        
        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
        
        .combo-display {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.8);
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            display: none;
        }
        
        .achievement-notification {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform 0.5s ease;
            z-index: 1000;
        }
        
        .achievement-notification.show {
            transform: translateX(0);
        }
        
        .power-up {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .loading-content {
            text-align: center;
            color: white;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }
        
        .level-display {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 123, 255, 0.8);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 16px;
            display: none;
        }
        
        .coin-reward {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .coin-reward h2 {
            font-size: 36px;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .coin-reward .coin-amount {
            font-size: 48px;
            margin: 20px 0;
            color: #ffd700;
        }
        
        .coin-reward button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .coin-reward button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="connection-status disconnected" id="connectionStatus">Disconnected</div>
        <div class="debug-info" id="debugInfo"></div>
        <div class="combo-display" id="comboDisplay">COMBO: 0</div>
        <div class="level-display" id="levelDisplay">Level 1</div>
        <div class="achievement-notification" id="achievementNotification">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div class="achievement-name" id="achievementName"></div>
        </div>
        <div class="game-info" id="gameInfo">
            <div class="health-bar-container">
                <span>Player 1</span>
                <div class="health-bar">
                    <div class="health-fill player" id="playerHealth"></div>
                </div>
            </div>
            <div class="player2-info" id="player2Info" style="display: none;">
                <span>Player 2</span>
                <div class="health-bar">
                    <div class="health-fill player2" id="player2Health"></div>
                </div>
            </div>
            <div class="charge-bar-container">
                <span>Special</span>
                <div class="charge-bar">
                    <div class="charge-fill" id="chargeFill"></div>
                </div>
            </div>
            <div class="health-bar-container" id="cpuHealthContainer">
                <div class="health-bar">
                    <div class="health-fill cpu" id="cpuHealth"></div>
                </div>
                <span>CPU</span>
            </div>
        </div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="controls">
            <h3>Controls</h3>
            <div class="control-row">
                <span><span class="key">A</span> <span class="key">D</span> Move</span>
                <span><span class="key">W</span> Jump</span>
                <span><span class="key">Space</span> Punch</span>
                <span><span class="key">F</span> Kick</span>
                <span><span class="key">Q</span> Special</span>
            </div>
        </div>
    </div>
    
    <div class="start-screen" id="startScreen">
        <h1>Stickman Fighter</h1>
        <div class="coin-display">
            <span class="coin-icon"></span>
            <span id="coinCount">0</span>
        </div>
        <p>Choose your fighter and defeat the CPU opponent!</p>
        <p>Earn coins by playing to unlock new characters</p>
        <button onclick="showCharacterSelection()">Choose Character</button>
    </div>
    
    <div class="character-selection" id="characterSelection">
        <h1>Select Your Fighter</h1>
        <div class="coin-display">
            <span class="coin-icon"></span>
            <span id="coinCountSelection">0</span>
        </div>
        <p class="selection-instruction">Click on a character to select them</p>
        <div class="characters-grid" id="charactersGrid"></div>
        <div class="start-button-container">
            <button id="startGameBtn" disabled onclick="showModeSelection()">SELECT MODE</button>
        </div>
    </div>
    
    <div class="mode-selection" id="modeSelection">
        <h1>Select Game Mode</h1>
        <div class="mode-buttons">
            <button class="mode-button" onclick="showDifficultySelection()">Classic Mode</button>
            <button class="mode-button" onclick="startGame('survival')">Survival Mode</button>
            <button class="mode-button" onclick="enterOnlineMode()">Online Mode</button>
        </div>
        <div class="mode-description">
            <p><strong>Classic Mode:</strong> Fight against a single CPU opponent</p>
            <p><strong>Survival Mode:</strong> Endless enemies with increasing difficulty!</p>
            <p><strong>Online Mode:</strong> Battle against other players online!</p>
        </div>
    </div>
    
    <div class="difficulty-selection" id="difficultySelection">
        <h1>Select Difficulty</h1>
        <div class="difficulty-buttons">
            <button class="difficulty-button" onclick="startGame('classic', 'normal')">Normal</button>
            <button class="difficulty-button" onclick="startGame('classic', 'hard')">Hard</button>
        </div>
        <div class="difficulty-description">
            <p><strong>Normal:</strong> Standard CPU opponent</p>
            <p><strong>Hard:</strong> Tougher CPU with more health and damage</p>
        </div>
    </div>
    
    <div class="online-lobby" id="onlineLobby">
        <h1>Online Mode</h1>
        <div class="lobby-status" id="lobbyStatus">Connecting to server...</div>
        <div class="loading-spinner"></div>
        <button class="cancel-button" onclick="cancelOnlineMode()">Cancel</button>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2 id="gameOverText">Game Over</h2>
        <p id="gameOverMessage"></p>
        <div class="coin-reward" id="coinReward">
            <h2>Coins Earned!</h2>
            <div class="coin-amount" id="coinAmount">+0</div>
            <button onclick="closeCoinReward()">Continue</button>
        </div>
        <button onclick="showCharacterSelection()">Play Again</button>
    </div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Game configuration constants
        const CONFIG = {
            GRAVITY: 0.8,
            GROUND_Y: 300,
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 400,
            STUN_DURATION: 120, // 2 seconds at 60fps
            SLOW_DURATION: 300, // 5 seconds
            SPECIAL_COOLDOWN: 180, // 3 seconds
            PARTICLE_COUNT: {
                DEATH_EFFECT: 20,
                SPAWN_EFFECT: 15,
                GROUND_SLAM: 30
            }
        };
        
        // Game state management
        const GameState = {
            MENU: 'menu',
            CHARACTER_SELECT: 'character_select',
            MODE_SELECT: 'mode_select',
            DIFFICULTY_SELECT: 'difficulty_select',
            ONLINE_LOBBY: 'online_lobby',
            PLAYING: 'playing',
            GAME_OVER: 'game_over'
        };
        
        let currentGameState = GameState.MENU;
        
        // Debug system
        const DEBUG = {
            enabled: false,
            showHitboxes: false,
            showFPS: false,
            fps: 0,
            frameCount: 0,
            lastFPSUpdate: 0,
            
            toggle: function() {
                this.enabled = !this.enabled;
                document.getElementById('debugInfo').style.display = this.enabled ? 'block' : 'none';
            },
            
            update: function(timestamp) {
                this.frameCount++;
                if (timestamp - this.lastFPSUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFPSUpdate = timestamp;
                    if (this.enabled) {
                        document.getElementById('debugInfo').textContent = `FPS: ${this.fps}`;
                    }
                }
            }
        };
        
        // Easing functions
        const Easing = {
            easeInOutQuad: function(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            },
            
            easeOutBounce: function(t) {
                if (t < 1/2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2/2.75) {
                    return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                } else if (t < 2.5/2.75) {
                    return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
                }
            }
        };
        
        // Screen shake effect
        const screenShake = {
            intensity: 0,
            duration: 0,
            
            shake: function(intensity, duration) {
                this.intensity = intensity;
                this.duration = duration;
            },
            
            update: function() {
                if (this.duration > 0) {
                    this.duration--;
                    const offsetX = (Math.random() - 0.5) * this.intensity;
                    const offsetY = (Math.random() - 0.5) * this.intensity;
                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                }
            },
            
            restore: function() {
                if (this.duration > 0) {
                    ctx.restore();
                }
            }
        };
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let animationId;
        let selectedCharacter = null;
        let gameMode = 'classic';
        let gameDifficulty = 'normal';
        let enemies = [];
        let particles = [];
        let isOnlineMode = false;
        let socket = null;
        let roomId = null;
        let isPlayer1 = true;
        let player2Data = null;
        let lastTime = 0;
        let powerUps = [];
        let achievements = [
            { id: 'first_win', name: 'First Victory', description: 'Win your first match', unlocked: false },
            { id: 'combo_master', name: 'Combo Master', description: 'Get a 10-hit combo', unlocked: false },
            { id: 'specialist', name: 'Specialist', description: 'Use special attacks 50 times', unlocked: false },
            { id: 'survivor', name: 'Survivor', description: 'Survive 5 minutes in survival mode', unlocked: false }
        ];
        let specialAttackCount = 0;
        let survivalStartTime = 0;
        
        // Coin system
        let coins = 0;
        let unlockedCharacters = ['fighter']; // Start with fighter unlocked
        
        // Character definitions with unlock costs
        const characters = [
            {
                id: 'fighter',
                name: 'Fighter',
                color: '#4CAF50',
                accessories: [],
                stats: { damage: 1.0, speed: 5, range: 60, health: 100 },
                specialAttack: 'uppercut',
                specialDescription: 'Uppercut - Launches enemies',
                description: 'Well-rounded fighter',
                cost: 0
            },
            {
                id: 'brawler',
                name: 'Brawler',
                color: '#ff4444',
                accessories: ['sunglasses'],
                stats: { damage: 1.5, speed: 4, range: 60, health: 100 },
                specialAttack: 'groundSlam',
                specialDescription: 'Ground Slam - Stuns all enemies',
                description: 'High damage but slower',
                cost: 100
            },
            {
                id: 'ninja',
                name: 'Ninja',
                color: '#4444ff',
                accessories: ['headband'],
                stats: { damage: 0.8, speed: 7, range: 60, health: 90 },
                specialAttack: 'shadowDash',
                specialDescription: 'Shadow Dash - Teleport and damage',
                description: 'Fast but lower damage',
                cost: 150
            },
            {
                id: 'cowboy',
                name: 'Cowboy',
                color: '#ffaa00',
                accessories: ['cowboy_hat'],
                stats: { damage: 1.0, speed: 5, range: 80, health: 100 },
                specialAttack: 'multiShot',
                specialDescription: 'Multi Shot - Fires in all directions',
                description: 'Long range attacks',
                cost: 200
            },
            {
                id: 'mage',
                name: 'Mage',
                color: '#9b59b6',
                accessories: ['wizard_hat'],
                stats: { damage: 1.3, speed: 4.5, range: 90, health: 90 },
                specialAttack: 'fireball',
                specialDescription: 'Fireball - Explosive projectile attack',
                description: 'Powerful magic attacks',
                cost: 250
            },
            {
                id: 'warrior',
                name: 'Warrior',
                color: '#e67e22',
                accessories: ['helmet', 'shield'],
                stats: { damage: 1.2, speed: 4, range: 50, health: 130 },
                specialAttack: 'berserkerRage',
                specialDescription: 'Berserker Rage - Temporary damage boost',
                description: 'Tank with high health and defense',
                cost: 300
            },
            {
                id: 'robot',
                name: 'Robot',
                color: '#888888',
                accessories: ['antenna'],
                stats: { damage: 1.3, speed: 4.5, range: 65, health: 120 },
                specialAttack: 'laserBeam',
                specialDescription: 'Laser Beam - Sweeping attack',
                description: 'Tank with high health',
                cost: 400
            },
            {
                id: 'archer',
                name: 'Archer',
                color: '#27ae60',
                accessories: ['quiver'],
                stats: { damage: 1.4, speed: 5.5, range: 100, health: 95 },
                specialAttack: 'arrowRain',
                specialDescription: 'Arrow Rain - Multiple arrows from above',
                description: 'High damage with long range',
                cost: 350
            },
            {
                id: 'monk',
                name: 'Monk',
                color: '#f39c12',
                accessories: ['beads'],
                stats: { damage: 1.1, speed: 6, range: 55, health: 110 },
                specialAttack: 'heal',
                specialDescription: 'Heal - Restore health and damage boost',
                description: 'Balanced with healing abilities',
                cost: 450
            }
        ];
        
        // Game objects
        let player = {
            x: 100,
            y: 300,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: null,
            attackCooldown: 0,
            attackFrame: 0,
            facing: 'right',
            color: '#4CAF50',
            accessories: [],
            damageMultiplier: 1.0,
            attackRange: 60,
            charge: 0,
            maxCharge: 100,
            specialCooldown: 0,
            isUsingSpecial: false,
            isLocalPlayer: true,
            stunned: false,
            stunTimer: 0,
            combo: { count: 0, timer: 0, multiplier: 1 },
            level: 1,
            experience: 0,
            expToNextLevel: 100,
            wins: 0
        };
        
        let player2 = {
            x: 600,
            y: 300,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: null,
            attackCooldown: 0,
            attackFrame: 0,
            facing: 'left',
            color: '#4444ff',
            accessories: [],
            damageMultiplier: 1.0,
            attackRange: 60,
            charge: 0,
            maxCharge: 100,
            specialCooldown: 0,
            isUsingSpecial: false,
            isLocalPlayer: false,
            stunned: false,
            stunTimer: 0,
            combo: { count: 0, timer: 0, multiplier: 1 }
        };
        
        function createEnemy(x = 600, difficulty = 'normal') {
            const enemy = {
                x: x,
                y: 300,
                width: 40,
                height: 60,
                velocityX: 0,
                velocityY: 0,
                speed: 3,
                jumpPower: 12,
                health: 100,
                maxHealth: 100,
                isAttacking: false,
                attackType: null,
                attackCooldown: 0,
                attackFrame: 0,
                facing: 'left',
                color: '#f44336',
                accessories: [],
                aiDecision: 0,
                aiCooldown: 0,
                alive: true,
                slowed: false,
                slowTimer: 0,
                stunned: false,
                stunTimer: 0,
                aiEnabled: true
            };
            
            // Apply difficulty modifiers
            if (difficulty === 'hard') {
                enemy.health = 150;
                enemy.maxHealth = 150;
                enemy.speed = 4.5;
                enemy.damageMultiplier = 1.5;
                enemy.attackRange = 70;
            }
            return enemy;
        }
        
        function createPowerUp(x, y, type) {
            return {
                x: x, y: y, width: 20, height: 20,
                type: type, // 'health', 'speed', 'damage', 'charge'
                collected: false,
                color: type === 'health' ? '#ff4444' : 
                       type === 'speed' ? '#44ff44' : 
                       type === 'damage' ? '#4444ff' : '#ffff00'
            };
        }
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Debug toggle
            if (e.key === 'F1') {
                DEBUG.toggle();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // Drawing functions
        function drawAccessory(character, accessory) {
            const centerX = character.x + character.width/2;
            const headY = character.y - 10;
            ctx.save();
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#333';
            ctx.lineWidth = 2;
            
            switch(accessory) {
                case 'sunglasses':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 12, headY - 2);
                    ctx.lineTo(centerX + 12, headY - 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(centerX - 6<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #90EE90 50%, #7CFC00 100%);
            border: 3px solid #333;
            border-radius: 10px;
            display: block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: white;
        }
        
        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .health-bar {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.1s ease;
            border-radius: 13px;
        }
        
        .health-fill.player {
            background: linear-gradient(90deg, #44ff44, #66ff66);
        }
        
        .health-fill.player2 {
            background: linear-gradient(90deg, #4444ff, #6666ff);
        }
        
        .charge-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .charge-bar {
            width: 150px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        .charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ffdd00);
            transition: width 0.2s ease;
            border-radius: 8px;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
            color: white;
            font-size: 14px;
        }
        
        .controls h3 {
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .control-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 5px 0;
        }
        
        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-weight: bold;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }
        
        .game-over h2 {
            font-size: 36px;
            margin-bottom: 15px;
        }
        
        .game-over button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .game-over button:hover {
            transform: scale(1.05);
        }
        
        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
        }
        
        .start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .coin-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            font-size: 24px;
            color: #ffd700;
        }
        
        .coin-icon {
            width: 30px;
            height: 30px;
            background: #ffd700;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .coin-icon::before {
            content: "$";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
        }
        
        .start-screen button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 20px;
        }
        
        .start-screen button:hover {
            transform: scale(1.05);
        }
        
        .character-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .character-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .character-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .character-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .character-card.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.3);
        }
        
        .character-card.locked {
            background: rgba(50, 50, 50, 0.3);
            border-color: #555;
            cursor: not-allowed;
        }
        
        .character-card.locked:hover {
            transform: none;
        }
        
        .lock-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
        }
        
        .lock-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .unlock-cost {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 18px;
            color: #ffd700;
        }
        
        .small-coin {
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            display: inline-block;
            position: relative;
        }
        
        .small-coin::before {
            content: "$";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
            font-size: 12px;
        }
        
        .character-preview {
            width: 100px;
            height: 120px;
            margin: 0 auto 15px;
            position: relative;
        }
        
        .character-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .character-stats {
            font-size: 14px;
            line-height: 1.6;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stat-bar {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-left: 10px;
        }
        
        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #44ff44, #66ff66);
            border-radius: 4px;
        }
        
        .start-button-container {
            margin-top: 30px;
            text-align: center;
        }
        
        #startGameBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin: 0 auto;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #startGameBtn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        #startGameBtn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .selection-instruction {
            margin-bottom: 20px;
            font-size: 18px;
            color: #ccc;
        }
        
        .mode-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 600px;
        }
        
        .mode-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .mode-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 30px;
            font-size: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .mode-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .mode-description {
            margin-top: 20px;
            font-size: 16px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .special-attack-info {
            margin-top: 10px;
            font-size: 12px;
            color: #ffaa00;
        }
        
        .difficulty-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 500px;
        }
        
        .difficulty-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .difficulty-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .difficulty-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .difficulty-description {
            margin-top: 20px;
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .online-lobby {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 500px;
        }
        
        .online-lobby h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .lobby-status {
            font-size: 18px;
            margin-bottom: 20px;
            color: #ccc;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .cancel-button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        
        .cancel-button:hover {
            background: #ff6666;
            transform: scale(1.05);
        }
        
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .connected {
            background: #44ff44;
            color: #000;
        }
        
        .disconnected {
            background: #ff4444;
            color: #fff;
        }
        
        .player2-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }
        
        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
        
        .combo-display {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.8);
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            display: none;
        }
        
        .achievement-notification {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform 0.5s ease;
            z-index: 1000;
        }
        
        .achievement-notification.show {
            transform: translateX(0);
        }
        
        .power-up {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .loading-content {
            text-align: center;
            color: white;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }
        
        .level-display {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 123, 255, 0.8);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 16px;
            display: none;
        }
        
        .coin-reward {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .coin-reward h2 {
            font-size: 36px;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .coin-reward .coin-amount {
            font-size: 48px;
            margin: 20px 0;
            color: #ffd700;
        }
        
        .coin-reward button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .coin-reward button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="connection-status disconnected" id="connectionStatus">Disconnected</div>
        <div class="debug-info" id="debugInfo"></div>
        <div class="combo-display" id="comboDisplay">COMBO: 0</div>
        <div class="level-display" id="levelDisplay">Level 1</div>
        <div class="achievement-notification" id="achievementNotification">
            <div class="achievement-title">Achievement Unlocked!</div>
            <div class="achievement-name" id="achievementName"></div>
        </div>
        <div class="game-info" id="gameInfo">
            <div class="health-bar-container">
                <span>Player 1</span>
                <div class="health-bar">
                    <div class="health-fill player" id="playerHealth"></div>
                </div>
            </div>
            <div class="player2-info" id="player2Info" style="display: none;">
                <span>Player 2</span>
                <div class="health-bar">
                    <div class="health-fill player2" id="player2Health"></div>
                </div>
            </div>
            <div class="charge-bar-container">
                <span>Special</span>
                <div class="charge-bar">
                    <div class="charge-fill" id="chargeFill"></div>
                </div>
            </div>
            <div class="health-bar-container" id="cpuHealthContainer">
                <div class="health-bar">
                    <div class="health-fill cpu" id="cpuHealth"></div>
                </div>
                <span>CPU</span>
            </div>
        </div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="controls">
            <h3>Controls</h3>
            <div class="control-row">
                <span><span class="key">A</span> <span class="key">D</span> Move</span>
                <span><span class="key">W</span> Jump</span>
                <span><span class="key">Space</span> Punch</span>
                <span><span class="key">F</span> Kick</span>
                <span><span class="key">Q</span> Special</span>
            </div>
        </div>
    </div>
    
    <div class="start-screen" id="startScreen">
        <h1>Stickman Fighter</h1>
        <div class="coin-display">
            <span class="coin-icon"></span>
            <span id="coinCount">0</span>
        </div>
        <p>Choose your fighter and defeat the CPU opponent!</p>
        <p>Earn coins by playing to unlock new characters</p>
        <button onclick="showCharacterSelection()">Choose Character</button>
    </div>
    
    <div class="character-selection" id="characterSelection">
        <h1>Select Your Fighter</h1>
        <div class="coin-display">
            <span class="coin-icon"></span>
            <span id="coinCountSelection">0</span>
        </div>
        <p class="selection-instruction">Click on a character to select them</p>
        <div class="characters-grid" id="charactersGrid"></div>
        <div class="start-button-container">
            <button id="startGameBtn" disabled onclick="showModeSelection()">SELECT MODE</button>
        </div>
    </div>
    
    <div class="mode-selection" id="modeSelection">
        <h1>Select Game Mode</h1>
        <div class="mode-buttons">
            <button class="mode-button" onclick="showDifficultySelection()">Classic Mode</button>
            <button class="mode-button" onclick="startGame('survival')">Survival Mode</button>
            <button class="mode-button" onclick="enterOnlineMode()">Online Mode</button>
        </div>
        <div class="mode-description">
            <p><strong>Classic Mode:</strong> Fight against a single CPU opponent</p>
            <p><strong>Survival Mode:</strong> Endless enemies with increasing difficulty!</p>
            <p><strong>Online Mode:</strong> Battle against other players online!</p>
        </div>
    </div>
    
    <div class="difficulty-selection" id="difficultySelection">
        <h1>Select Difficulty</h1>
        <div class="difficulty-buttons">
            <button class="difficulty-button" onclick="startGame('classic', 'normal')">Normal</button>
            <button class="difficulty-button" onclick="startGame('classic', 'hard')">Hard</button>
        </div>
        <div class="difficulty-description">
            <p><strong>Normal:</strong> Standard CPU opponent</p>
            <p><strong>Hard:</strong> Tougher CPU with more health and damage</p>
        </div>
    </div>
    
    <div class="online-lobby" id="onlineLobby">
        <h1>Online Mode</h1>
        <div class="lobby-status" id="lobbyStatus">Connecting to server...</div>
        <div class="loading-spinner"></div>
        <button class="cancel-button" onclick="cancelOnlineMode()">Cancel</button>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2 id="gameOverText">Game Over</h2>
        <p id="gameOverMessage"></p>
        <div class="coin-reward" id="coinReward">
            <h2>Coins Earned!</h2>
            <div class="coin-amount" id="coinAmount">+0</div>
            <button onclick="closeCoinReward()">Continue</button>
        </div>
        <button onclick="showCharacterSelection()">Play Again</button>
    </div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Game configuration constants
        const CONFIG = {
            GRAVITY: 0.8,
            GROUND_Y: 300,
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 400,
            STUN_DURATION: 120, // 2 seconds at 60fps
            SLOW_DURATION: 300, // 5 seconds
            SPECIAL_COOLDOWN: 180, // 3 seconds
            PARTICLE_COUNT: {
                DEATH_EFFECT: 20,
                SPAWN_EFFECT: 15,
                GROUND_SLAM: 30
            }
        };
        
        // Game state management
        const GameState = {
            MENU: 'menu',
            CHARACTER_SELECT: 'character_select',
            MODE_SELECT: 'mode_select',
            DIFFICULTY_SELECT: 'difficulty_select',
            ONLINE_LOBBY: 'online_lobby',
            PLAYING: 'playing',
            GAME_OVER: 'game_over'
        };
        
        let currentGameState = GameState.MENU;
        
        // Debug system
        const DEBUG = {
            enabled: false,
            showHitboxes: false,
            showFPS: false,
            fps: 0,
            frameCount: 0,
            lastFPSUpdate: 0,
            
            toggle: function() {
                this.enabled = !this.enabled;
                document.getElementById('debugInfo').style.display = this.enabled ? 'block' : 'none';
            },
            
            update: function(timestamp) {
                this.frameCount++;
                if (timestamp - this.lastFPSUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFPSUpdate = timestamp;
                    if (this.enabled) {
                        document.getElementById('debugInfo').textContent = `FPS: ${this.fps}`;
                    }
                }
            }
        };
        
        // Easing functions
        const Easing = {
            easeInOutQuad: function(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            },
            
            easeOutBounce: function(t) {
                if (t < 1/2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2/2.75) {
                    return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                } else if (t < 2.5/2.75) {
                    return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
                }
            }
        };
        
        // Screen shake effect
        const screenShake = {
            intensity: 0,
            duration: 0,
            
            shake: function(intensity, duration) {
                this.intensity = intensity;
                this.duration = duration;
            },
            
            update: function() {
                if (this.duration > 0) {
                    this.duration--;
                    const offsetX = (Math.random() - 0.5) * this.intensity;
                    const offsetY = (Math.random() - 0.5) * this.intensity;
                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                }
            },
            
            restore: function() {
                if (this.duration > 0) {
                    ctx.restore();
                }
            }
        };
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let animationId;
        let selectedCharacter = null;
        let gameMode = 'classic';
        let gameDifficulty = 'normal';
        let enemies = [];
        let particles = [];
        let isOnlineMode = false;
        let socket = null;
        let roomId = null;
        let isPlayer1 = true;
        let player2Data = null;
        let lastTime = 0;
        let powerUps = [];
        let achievements = [
            { id: 'first_win', name: 'First Victory', description: 'Win your first match', unlocked: false },
            { id: 'combo_master', name: 'Combo Master', description: 'Get a 10-hit combo', unlocked: false },
            { id: 'specialist', name: 'Specialist', description: 'Use special attacks 50 times', unlocked: false },
            { id: 'survivor', name: 'Survivor', description: 'Survive 5 minutes in survival mode', unlocked: false }
        ];
        let specialAttackCount = 0;
        let survivalStartTime = 0;
        
        // Coin system
        let coins = 0;
        let unlockedCharacters = ['fighter']; // Start with fighter unlocked
        
        // Character definitions with unlock costs
        const characters = [
            {
                id: 'fighter',
                name: 'Fighter',
                color: '#4CAF50',
                accessories: [],
                stats: { damage: 1.0, speed: 5, range: 60, health: 100 },
                specialAttack: 'uppercut',
                specialDescription: 'Uppercut - Launches enemies',
                description: 'Well-rounded fighter',
                cost: 0
            },
            {
                id: 'brawler',
                name: 'Brawler',
                color: '#ff4444',
                accessories: ['sunglasses'],
                stats: { damage: 1.5, speed: 4, range: 60, health: 100 },
                specialAttack: 'groundSlam',
                specialDescription: 'Ground Slam - Stuns all enemies',
                description: 'High damage but slower',
                cost: 100
            },
            {
                id: 'ninja',
                name: 'Ninja',
                color: '#4444ff',
                accessories: ['headband'],
                stats: { damage: 0.8, speed: 7, range: 60, health: 90 },
                specialAttack: 'shadowDash',
                specialDescription: 'Shadow Dash - Teleport and damage',
                description: 'Fast but lower damage',
                cost: 150
            },
            {
                id: 'cowboy',
                name: 'Cowboy',
                color: '#ffaa00',
                accessories: ['cowboy_hat'],
                stats: { damage: 1.0, speed: 5, range: 80, health: 100 },
                specialAttack: 'multiShot',
                specialDescription: 'Multi Shot - Fires in all directions',
                description: 'Long range attacks',
                cost: 200
            },
            {
                id: 'mage',
                name: 'Mage',
                color: '#9b59b6',
                accessories: ['wizard_hat'],
                stats: { damage: 1.3, speed: 4.5, range: 90, health: 90 },
                specialAttack: 'fireball',
                specialDescription: 'Fireball - Explosive projectile attack',
                description: 'Powerful magic attacks',
                cost: 250
            },
            {
                id: 'warrior',
                name: 'Warrior',
                color: '#e67e22',
                accessories: ['helmet', 'shield'],
                stats: { damage: 1.2, speed: 4, range: 50, health: 130 },
                specialAttack: 'berserkerRage',
                specialDescription: 'Berserker Rage - Temporary damage boost',
                description: 'Tank with high health and defense',
                cost: 300
            },
            {
                id: 'robot',
                name: 'Robot',
                color: '#888888',
                accessories: ['antenna'],
                stats: { damage: 1.3, speed: 4.5, range: 65, health: 120 },
                specialAttack: 'laserBeam',
                specialDescription: 'Laser Beam - Sweeping attack',
                description: 'Tank with high health',
                cost: 400
            },
            {
                id: 'archer',
                name: 'Archer',
                color: '#27ae60',
                accessories: ['quiver'],
                stats: { damage: 1.4, speed: 5.5, range: 100, health: 95 },
                specialAttack: 'arrowRain',
                specialDescription: 'Arrow Rain - Multiple arrows from above',
                description: 'High damage with long range',
                cost: 350
            },
            {
                id: 'monk',
                name: 'Monk',
                color: '#f39c12',
                accessories: ['beads'],
                stats: { damage: 1.1, speed: 6, range: 55, health: 110 },
                specialAttack: 'heal',
                specialDescription: 'Heal - Restore health and damage boost',
                description: 'Balanced with healing abilities',
                cost: 450
            }
        ];
        
        // Game objects
        let player = {
            x: 100,
            y: 300,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: null,
            attackCooldown: 0,
            attackFrame: 0,
            facing: 'right',
            color: '#4CAF50',
            accessories: [],
            damageMultiplier: 1.0,
            attackRange: 60,
            charge: 0,
            maxCharge: 100,
            specialCooldown: 0,
            isUsingSpecial: false,
            isLocalPlayer: true,
            stunned: false,
            stunTimer: 0,
            combo: { count: 0, timer: 0, multiplier: 1 },
            level: 1,
            experience: 0,
            expToNextLevel: 100,
            wins: 0
        };
        
        let player2 = {
            x: 600,
            y: 300,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: null,
            attackCooldown: 0,
            attackFrame: 0,
            facing: 'left',
            color: '#4444ff',
            accessories: [],
            damageMultiplier: 1.0,
            attackRange: 60,
            charge: 0,
            maxCharge: 100,
            specialCooldown: 0,
            isUsingSpecial: false,
            isLocalPlayer: false,
            stunned: false,
            stunTimer: 0,
            combo: { count: 0, timer: 0, multiplier: 1 }
        };
        
        function createEnemy(x = 600, difficulty = 'normal') {
            const enemy = {
                x: x,
                y: 300,
                width: 40,
                height: 60,
                velocityX: 0,
                velocityY: 0,
                speed: 3,
                jumpPower: 12,
                health: 100,
                maxHealth: 100,
                isAttacking: false,
                attackType: null,
                attackCooldown: 0,
                attackFrame: 0,
                facing: 'left',
                color: '#f44336',
                accessories: [],
                aiDecision: 0,
                aiCooldown: 0,
                alive: true,
                slowed: false,
                slowTimer: 0,
                stunned: false,
                stunTimer: 0,
                aiEnabled: true
            };
            
            // Apply difficulty modifiers
            if (difficulty === 'hard') {
                enemy.health = 150;
                enemy.maxHealth = 150;
                enemy.speed = 4.5;
                enemy.damageMultiplier = 1.5;
                enemy.attackRange = 70;
            }
            return enemy;
        }
        
        function createPowerUp(x, y, type) {
            return {
                x: x, y: y, width: 20, height: 20,
                type: type, // 'health', 'speed', 'damage', 'charge'
                collected: false,
                color: type === 'health' ? '#ff4444' : 
                       type === 'speed' ? '#44ff44' : 
                       type === 'damage' ? '#4444ff' : '#ffff00'
            };
        }
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Debug toggle
            if (e.key === 'F1') {
                DEBUG.toggle();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // Drawing functions
        function drawAccessory(character, accessory) {
            const centerX = character.x + character.width/2;
            const headY = character.y - 10;
            ctx.save();
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#333';
            ctx.lineWidth = 2;
            
            switch(accessory) {
                case 'sunglasses':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 12, headY - 2);
                    ctx.lineTo(centerX + 12, headY - 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(centerX - 6, headY - 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + 6, headY - 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'cowboy_hat':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 15, headY - 5);
                    ctx.lineTo(centerX + 15, headY - 5);
                    ctx.lineTo(centerX + 12, headY - 15);
                    ctx.lineTo(centerX - 12, headY - 15);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, headY - 5);
                    ctx.lineTo(centerX + 20, headY - 5);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                case 'top_hat':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 10, headY - 20);
                    ctx.lineTo(centerX + 10, headY - 20);
                    ctx.lineTo(centerX + 8, headY - 5);
                    ctx.lineTo(centerX - 8, headY - 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(centerX - 15, headY - 5);
                    ctx.lineTo(centerX + 15, headY - 5);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                case 'headband':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 12, headY - 8);
                    ctx.lineTo(centerX + 12, headY - 8);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(centerX - 2, headY - 12, 4, 4);
                    break;
                case 'wizard_hat':
                    ctx.beginPath();
                    ctx.moveTo(centerX, headY - 20);
                    ctx.lineTo(centerX - 15, headY - 5);
                    ctx.lineTo(centerX + 15, headY - 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX, headY - 25, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'helmet':
                    ctx.beginPath();
                    ctx.arc(centerX, headY - 5, 12, 0, Math.PI, true);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(centerX - 12, headY - 5);
                    ctx.lineTo(centerX - 15, headY + 5);
                    ctx.lineTo(centerX + 15, headY + 5);
                    ctx.lineTo(centerX + 12, headY - 5);
                    ctx.fill();
                    break;
                case 'shield':
                    ctx.beginPath();
                    ctx.arc(character.x + character.width/2 - 20, character.y + 20, 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(character.x + character.width/2 - 20, character.y + 5);
                    ctx.lineTo(character.x + character.width/2 - 20, character.y + 35);
                    ctx.stroke();
                    break;
                case 'antenna':
                    ctx.beginPath();
                    ctx.moveTo(centerX, headY - 10);
                    ctx.lineTo(centerX, headY - 20);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(centerX, headY - 22, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'quiver':
                    // Draw a quiver on the character's back
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(character.x + character.width/2 - 15, character.y + 10, 8, 25);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(character.x + character.width/2 - 15, character.y + 10, 8, 5);
                    break;
                case 'beads':
                    // Draw prayer beads around the neck
                    ctx.beginPath();
                    ctx.arc(centerX, character.y + 5, 8, 0, Math.PI);
                    ctx.stroke();
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.PI * (i / 4);
                        const beadX = centerX + Math.cos(angle) * 8;
                        const beadY = character.y + 5 + Math.sin(angle) * 8;
                        ctx.beginPath();
                        ctx.arc(beadX, beadY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
            }
            ctx.restore();
        }
        
        function drawStickman(character, label) {
            ctx.save();
            
            // Body
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            // Head
            ctx.beginPath();
            ctx.arc(character.x + character.width/2, character.y - 10, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw accessories
            if (character.accessories) {
                character.accessories.forEach(accessory => {
                    drawAccessory(character, accessory);
                });
            }
            
            // Body
            ctx.beginPath();
            ctx.moveTo(character.x + character.width/2, character.y);
            ctx.lineTo(character.x + character.width/2, character.y + 30);
            ctx.stroke();
            
            // Arms
            const armAngle = character.isAttacking ? 0.5 : 0.2;
            const armOffset = Math.sin(Date.now() * 0.01) * 5;
            
            // Back arm (always normal)
            const backArmX = character.x + character.width/2 + (character.facing === 'right' ? -15 : 15);
            const backArmY = character.y + 20 - armOffset;
            ctx.beginPath();
            ctx.moveTo(character.x + character.width/2, character.y + 10);
            ctx.lineTo(backArmX, backArmY);
            ctx.stroke();
            
            // Front arm (changes during punch)
            if (character.isAttacking && character.attackType === 'punch') {
                // Punching animation - extend arm forward
                const punchExtension = 20 + Math.sin(character.attackFrame * 0.5) * 5;
                const punchX = character.x + character.width/2 + (character.facing === 'right' ? punchExtension : -punchExtension);
                const punchY = character.y + 10;
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 10);
                ctx.lineTo(punchX, punchY);
                ctx.stroke();
                
                // Fist
                ctx.fillStyle = character.color;
                ctx.beginPath();
                ctx.arc(punchX, punchY, 5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Normal arm
                const frontArmX = character.x + character.width/2 + (character.facing === 'right' ? 15 : -15);
                const frontArmY = character.y + 20 + armOffset;
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 10);
                ctx.lineTo(frontArmX, frontArmY);
                ctx.stroke();
            }
            
            // Legs
            const legOffset = Math.sin(Date.now() * 0.02) * 5;
            
            // Back leg (always normal)
            const backLegX = character.x + character.width/2 - 10;
            const backLegY = character.y + character.height + legOffset;
            ctx.beginPath();
            ctx.moveTo(character.x + character.width/2, character.y + 30);
            ctx.lineTo(backLegX, backLegY);
            ctx.stroke();
            
            // Front leg (changes during kick)
            if (character.isAttacking && character.attackType === 'kick') {
                // Kicking animation - extend leg forward
                const kickExtension = 25 + Math.sin(character.attackFrame * 0.4) * 8;
                const kickX = character.x + character.width/2 + (character.facing === 'right' ? kickExtension : -kickExtension);
                const kickY = character.y + 30;
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 30);
                ctx.lineTo(kickX, kickY);
                ctx.stroke();
                
                // Foot
                ctx.fillStyle = character.color;
                ctx.beginPath();
                ctx.arc(kickX, kickY, 6, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Normal leg
                const frontLegX = character.x + character.width/2 + 10;
                const frontLegY = character.y + character.height - legOffset;
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 30);
                ctx.lineTo(frontLegX, frontLegY);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function createDeathEffect(x, y) {
            for (let i = 0; i < CONFIG.PARTICLE_COUNT.DEATH_EFFECT; i++) {
                particlePool.create(x, y, 'death');
            }
        }
        
        function createSpawnEffect(x, y) {
            for (let i = 0; i < CONFIG.PARTICLE_COUNT.SPAWN_EFFECT; i++) {
                particlePool.create(x, y, 'spawn');
            }
        }
        
        function createPowerUpEffect(x, y) {
            for (let i = 0; i < 15; i++) {
                particlePool.create(x, y, 'powerup');
            }
        }
        
        // Save and load game data
        function saveGameData() {
            const gameData = {
                coins: coins,
                unlockedCharacters: unlockedCharacters,
                achievements: achievements,
                playerWins: player.wins
            };
            localStorage.setItem('stickmanFighterData', JSON.stringify(gameData));
        }
        
        function loadGameData() {
            const savedData = localStorage.getItem('stickmanFighterData');
            if (savedData) {
                const gameData = JSON.parse(savedData);
                coins = gameData.coins || 0;
                unlockedCharacters = gameData.unlockedCharacters || ['fighter'];
                achievements = gameData.achievements || achievements;
                player.wins = gameData.playerWins || 0;
            }
            updateCoinDisplay();
        }
        
        function updateCoinDisplay() {
            document.getElementById('coinCount').textContent = coins;
            document.getElementById('coinCountSelection').textContent = coins;
        }
        
        function addCoins(amount) {
            coins += amount;
            updateCoinDisplay();
            saveGameData();
        }
        
        function unlockCharacter(characterId) {
            if (!unlockedCharacters.includes(characterId)) {
                unlockedCharacters.push(characterId);
                saveGameData();
            }
        }
        
        function isCharacterUnlocked(characterId) {
            return unlockedCharacters.includes(characterId);
        }
        
        // Character selection functions
        function showCharacterSelection() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('characterSelection').style.display = 'block';
            currentGameState = GameState.CHARACTER_SELECT;
            
            const grid = document.getElementById('charactersGrid');
            grid.innerHTML = '';
            
            characters.forEach(char => {
                const card = document.createElement('div');
                const isUnlocked = isCharacterUnlocked(char.id);
                card.className = `character-card ${isUnlocked ? '' : 'locked'}`;
                
                const preview = document.createElement('div');
                preview.className = 'character-preview';
                
                const name = document.createElement('div');
                name.className = 'character-name';
                name.textContent = char.name;
                
                const stats = document.createElement('div');
                stats.className = 'character-stats';
                
                // Create stat bars
                const damageStat = createStat('Damage', char.stats.damage, 1.8);
                const speedStat = createStat('Speed', char.stats.speed, 8);
                const rangeStat = createStat('Range', char.stats.range, 100);
                const healthStat = createStat('Health', char.stats.health, 130);
                
                stats.appendChild(damageStat);
                stats.appendChild(speedStat);
                stats.appendChild(rangeStat);
                stats.appendChild(healthStat);
                
                const desc = document.createElement('div');
                desc.style.fontSize = '12px';
                desc.style.marginTop = '10px';
                desc.style.color = '#ccc';
                desc.textContent = char.description;
                
                const special = document.createElement('div');
                special.className = 'special-attack-info';
                special.textContent = char.specialDescription;
                
                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(stats);
                card.appendChild(desc);
                card.appendChild(special);
                
                if (!isUnlocked) {
                    const lockOverlay = document.createElement('div');
                    lockOverlay.className = 'lock-overlay';
                    
                    const lockIcon = document.createElement('div');
                    lockIcon.className = 'lock-icon';
                    lockIcon.textContent = '🔒';
                    
                    const unlockCost = document.createElement('div');
                    unlockCost.className = 'unlock-cost';
                    unlockCost.innerHTML = `<span class="small-coin"></span> ${char.cost}`;
                    
                    lockOverlay.appendChild(lockIcon);
                    lockOverlay.appendChild(unlockCost);
                    card.appendChild(lockOverlay);
                    
                    card.onclick = () => {
                        if (coins >= char.cost) {
                            if (confirm(`Unlock ${char.name} for ${char.cost} coins?`)) {
                                addCoins(-char.cost);
                                unlockCharacter(char.id);
                                showCharacterSelection(); // Refresh the selection screen
                            }
                        } else {
                            alert(`You need ${char.cost} coins to unlock ${char.name}!`);
                        }
                    };
                } else {
                    card.onclick = () => selectCharacter(char);
                }
                
                grid.appendChild(card);
                
                // Draw character preview
                setTimeout(() => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 100;
                    canvas.height = 120;
                    preview.appendChild(canvas);
                    const ctx = canvas.getContext('2d');
                    
                    // Draw mini character
                    const miniChar = {
                        x: 30,
                        y: 60,
                        width: 40,
                        height: 60,
                        color: char.color,
                        accessories: char.accessories,
                        facing: 'right'
                    };
                    
                    ctx.strokeStyle = char.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(50, 50, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Accessories (mini version)
                    char.accessories.forEach(acc => {
                        drawMiniAccessory(ctx, 50, 50, acc);
                    });
                    
                    // Body
                    ctx.beginPath();
                    ctx.moveTo(50, 58);
                    ctx.lineTo(50, 78);
                    ctx.stroke();
                    
                    // Arms
                    ctx.beginPath();
                    ctx.moveTo(50, 63);
                    ctx.lineTo(40, 73);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(50, 63);
                    ctx.lineTo(60, 73);
                    ctx.stroke();
                    
                    // Legs
                    ctx.beginPath();
                    ctx.moveTo(50, 78);
                    ctx.lineTo(40, 98);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(50, 78);
                    ctx.lineTo(60, 98);
                    ctx.stroke();
                }, 10);
            });
        }
        
        function drawMiniAccessory(ctx, x, y, accessory) {
            ctx.save();
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#333';
            ctx.lineWidth = 1;
            
            switch(accessory) {
                case 'sunglasses':
                    ctx.fillRect(x - 8, y - 2, 16, 2);
                    ctx.beginPath();
                    ctx.arc(x - 4, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 4, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'cowboy_hat':
                    ctx.fillRect(x - 10, y - 15, 20, 10);
                    ctx.fillRect(x - 13, y - 5, 26, 2);
                    break;
                case 'top_hat':
                    ctx.fillRect(x - 6, y - 18, 12, 13);
                    ctx.fillRect(x - 10, y - 5, 20, 2);
                    break;
                case 'headband':
                    ctx.fillRect(x - 8, y - 8, 16, 2);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(x - 1, y - 11, 2, 3);
                    break;
                case 'wizard_hat':
                    ctx.beginPath();
                    ctx.moveTo(x, y - 15);
                    ctx.lineTo(x - 10, y - 5);
                    ctx.lineTo(x + 10, y - 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x, y - 20, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'helmet':
                    ctx.beginPath();
                    ctx.arc(x, y - 5, 8, 0, Math.PI, true);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y - 5);
                    ctx.lineTo(x - 10, y + 2);
                    ctx.lineTo(x + 10, y + 2);
                    ctx.lineTo(x + 8, y - 5);
                    ctx.fill();
                    break;
                case 'shield':
                    ctx.beginPath();
                    ctx.arc(x - 15, y + 10, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'antenna':
                    ctx.beginPath();
                    ctx.moveTo(x, y - 10);
                    ctx.lineTo(x, y - 15);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(x, y - 17, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'quiver':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x - 8, y + 5, 4, 10);
                    break;
                case 'beads':
                    ctx.beginPath();
                    ctx.arc(x, y + 3, 5, 0, Math.PI);
                    ctx.stroke();
                    break;
            }
            ctx.restore();
        }
        
        function createStat(name, value, max) {
            const stat = document.createElement('div');
            stat.className = 'stat';
            
            const label = document.createElement('span');
            label.textContent = name;
            
            const bar = document.createElement('div');
            bar.className = 'stat-bar';
            
            const fill = document.createElement('div');
            fill.className = 'stat-fill';
            fill.style.width = `${(value / max) * 100}%`;
            
            bar.appendChild(fill);
            stat.appendChild(label);
            stat.appendChild(bar);
            return stat;
        }
        
        function selectCharacter(character) {
            if (!isCharacterUnlocked(character.id)) return;
            
            selectedCharacter = character;
            
            // Update UI
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');
            
            // Enable start button
            const startBtn = document.getElementById('startGameBtn');
            startBtn.disabled = false;
            startBtn.textContent = 'SELECT MODE';
            
            // Scroll to button
            startBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        function showModeSelection() {
            if (!selectedCharacter) {
                alert('Please select a character first!');
                return;
            }
            document.getElementById('characterSelection').style.display = 'none';
            document.getElementById('modeSelection').style.display = 'block';
            currentGameState = GameState.MODE_SELECT;
        }
        
        function showDifficultySelection() {
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('difficultySelection').style.display = 'block';
            currentGameState = GameState.DIFFICULTY_SELECT;
        }
        
        function enterOnlineMode() {
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('onlineLobby').style.display = 'block';
            currentGameState = GameState.ONLINE_LOBBY;
            connectToServer();
        }
        
        function cancelOnlineMode() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            document.getElementById('onlineLobby').style.display = 'none';
            document.getElementById('modeSelection').style.display = 'block';
            currentGameState = GameState.MODE_SELECT;
            updateConnectionStatus(false);
        }
        
        function connectToServer() {
            try {
                socket = io();
                
                socket.on('connect', () => {
                    updateConnectionStatus(true);
                    document.getElementById('lobbyStatus').textContent = 'Connected! Finding match...';
                    socket.emit('findMatch');
                });
                
                socket.on('disconnect', () => {
                    updateConnectionStatus(false);
                });
                
                socket.on('matchFound', (data) => {
                    roomId = data.roomId;
                    isPlayer1 = data.isPlayer1;
                    document.getElementById('lobbyStatus').textContent = 'Match found! Starting game...';
                    setTimeout(() => {
                        document.getElementById('onlineLobby').style.display = 'none';
                        startOnlineGame();
                    }, 1000);
                });
                
                socket.on('playerJoined', (data) => {
                    if (data.playerId !== socket.id) {
                        player2Data = data;
                    }
                });
                
                socket.on('gameState', (data) => {
                    if (data.playerId !== socket.id) {
                        // Update opponent state
                        if (isPlayer1) {
                            player2.x = data.x;
                            player2.y = data.y;
                            player2.velocityX = data.velocityX;
                            player2.velocityY = data.velocityY;
                            player2.facing = data.facing;
                            player2.isAttacking = data.isAttacking;
                            player2.attackType = data.attackType;
                            player2.health = data.health;
                            player2.isUsingSpecial = data.isUsingSpecial;
                        } else {
                            player.x = data.x;
                            player.y = data.y;
                            player.velocityX = data.velocityX;
                            player.velocityY = data.velocityY;
                            player.facing = data.facing;
                            player.isAttacking = data.isAttacking;
                            player.attackType = data.attackType;
                            player.health = data.health;
                            player.isUsingSpecial = data.isUsingSpecial;
                        }
                    }
                });
                
                socket.on('specialAttack', (data) => {
                    if (data.playerId !== socket.id) {
                        // Execute opponent's special attack
                        const opponent = isPlayer1 ? player2 : player;
                        executeSpecialAttack(data.attackType, opponent);
                    }
                });
                
                socket.on('playerDisconnected', () => {
                    endGame('Player Disconnected', 'Your opponent left the game');
                });
            } catch (error) {
                console.error('Socket connection error:', error);
                endGame('Connection Error', 'Failed to connect to server');
            }
        }
        
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'Connected';
                status.className = 'connection-status connected';
            } else {
                status.textContent = 'Disconnected';
                status.className = 'connection-status disconnected';
            }
        }
        
        // Special attack functions
        function useSpecialAttack() {
            if (player.charge < player.maxCharge || player.specialCooldown > 0) return;
            player.isUsingSpecial = true;
            player.charge = 0;
            player.specialCooldown = CONFIG.SPECIAL_COOLDOWN;
            specialAttackCount++;
            
            // Send to server if online
            if (isOnlineMode && socket) {
                socket.emit('specialAttack', { roomId: roomId, attackType: selectedCharacter.specialAttack });
            }
            
            SoundMixer.playWithVolume('special', 'effects');
            
            switch(selectedCharacter.specialAttack) {
                case 'groundSlam':
                    groundSlam();
                    break;
                case 'shadowDash':
                    shadowDash();
                    break;
                case 'multiShot':
                    multiShot();
                    break;
                case 'timeField':
                    timeField();
                    break;
                case 'uppercut':
                    uppercut();
                    break;
                case 'fireball':
                    fireball();
                    break;
                case 'berserkerRage':
                    berserkerRage();
                    break;
                case 'laserBeam':
                    laserBeam();
                    break;
                case 'arrowRain':
                    arrowRain();
                    break;
                case 'heal':
                    heal();
                    break;
            }
            
            setTimeout(() => {
                player.isUsingSpecial = false;
            }, 500);
        }
        
        function executeSpecialAttack(attackType, target) {
            switch(attackType) {
                case 'groundSlam':
                    executeGroundSlam(target);
                    break;
                case 'shadowDash':
                    executeShadowDash(target);
                    break;
                case 'multiShot':
                    executeMultiShot(target);
                    break;
                case 'timeField':
                    executeTimeField(target);
                    break;
                case 'uppercut':
                    executeUppercut(target);
                    break;
                case 'fireball':
                    executeFireball(target);
                    break;
                case 'berserkerRage':
                    executeBerserkerRage(target);
                    break;
                case 'laserBeam':
                    executeLaserBeam(target);
                    break;
                case 'arrowRain':
                    executeArrowRain(target);
                    break;
                case 'heal':
                    executeHeal(target);
                    break;
            }
        }
        
        function groundSlam() {
            // Create shockwave effect
            for (let i = 0; i < CONFIG.PARTICLE_COUNT.GROUND_SLAM; i++) {
                particlePool.create(player.x + player.width/2, player.y + player.height, 'death');
            }
            
            SoundMixer.playWithVolume('ground_slam', 'effects');
            screenShake.shake(10, 20);
            
            // Damage all enemies in range
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive && target.health > 0) {
                    const distance = Math.abs(target.x - player.x);
                    if (distance < 150) {
                        target.health -= 40;
                        target.health = Math.max(0, target.health);
                        target.stunned = true;
                        target.stunTimer = CONFIG.STUN_DURATION;
                        target.velocityY = -15; // Launch enemies
                        
                        if (target.health <= 0 && target.alive) {
                            target.alive = false;
                            createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            awardExperience(20, true);
                        } else {
                            createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            awardExperience(5);
                        }
                    }
                }
            });
        }
        
        function executeGroundSlam(target) {
            // Create shockwave effect
            for (let i = 0; i < CONFIG.PARTICLE_COUNT.GROUND_SLAM; i++) {
                particlePool.create(target.x + target.width/2, target.y + target.height, 'death');
            }
            
            SoundMixer.playWithVolume('ground_slam', 'effects');
            screenShake.shake(10, 20);
            
            // Damage player
            const distance = Math.abs(player.x - target.x);
            if (distance < 150) {
                player.health -= 40;
                player.health = Math.max(0, player.health);
                player.stunned = true;
                player.stunTimer = CONFIG.STUN_DURATION;
                player.velocityY = -15;
                
                if (player.health <= 0) {
                    createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                } else {
                    createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                }
            }
        }
        
        function shadowDash() {
            const dashDistance = player.facing === 'right' ? 200 : -200;
            const startX = player.x;
            const endX = player.x + dashDistance;
            
            // Create shadow trail
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const trailX = startX + (dashDistance * i / 10);
                    for (let j = 0; j < 5; j++) {
                        particlePool.create(trailX + player.width/2, player.y + player.height/2, 'spawn');
                    }
                }, i * 20);
            }
            
            SoundMixer.playWithVolume('shadow_dash', 'effects');
            
            // Teleport and damage enemies along the path
            player.x = endX;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive && target.health > 0 && 
                    ((player.facing === 'right' && target.x > startX && target.x < endX) || 
                     (player.facing === 'left' && target.x < startX && target.x > endX))) {
                    target.health -= 30;
                    target.health = Math.max(0, target.health);
                    target.velocityY = -15;
                    
                    if (target.health <= 0 && target.alive) {
                        target.alive = false;
                        createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                        awardExperience(20, true);
                    } else {
                        createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                        awardExperience(5);
                    }
                }
            });
        }
        
        function executeShadowDash(target) {
            const dashDistance = target.facing === 'right' ? 200 : -200;
            const startX = target.x;
            const endX = target.x + dashDistance;
            
            // Create shadow trail
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const trailX = startX + (dashDistance * i / 10);
                    for (let j = 0; j < 5; j++) {
                        particlePool.create(trailX + target.width/2, target.y + target.height/2, 'spawn');
                    }
                }, i * 20);
            }
            
            SoundMixer.playWithVolume('shadow_dash', 'effects');
            
            // Damage player if in path
            if ((target.facing === 'right' && player.x > startX && player.x < endX) || 
                (target.facing === 'left' && player.x < startX && player.x > endX)) {
                player.health -= 30;
                player.health = Math.max(0, player.health);
                player.velocityY = -15;
                
                if (player.health <= 0) {
                    createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                } else {
                    createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                }
            }
        }
        
        function multiShot() {
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            SoundMixer.playWithVolume('multi_shot', 'effects');
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const projectile = {
                    x: player.x + player.width/2,
                    y: player.y + 20,
                    velocityX: Math.cos(rad) * 8,
                    velocityY: Math.sin(rad) * 8,
                    life: 60,
                    damage: 25
                };
                
                // Animate projectile
                const animateProjectile = () => {
                    if (projectile.life <= 0) return;
                    projectile.x += projectile.velocityX;
                    projectile.y += projectile.velocityY;
                    projectile.life--;
                    
                    // Draw projectile
                    ctx.save();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Check collision with targets
                    const targets = isOnlineMode ? [player2] : enemies;
                    targets.forEach(target => {
                        if (target.alive && target.health > 0) {
                            const distance = Math.sqrt(
                                Math.pow(target.x + target.width/2 - projectile.x, 2) +
                                Math.pow(target.y + target.height/2 - projectile.y, 2)
                            );
                            if (distance < 20) {
                                target.health -= projectile.damage;
                                target.health = Math.max(0, target.health);
                                
                                if (target.health <= 0 && target.alive) {
                                    target.alive = false;
                                    createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                    awardExperience(20, true);
                                } else {
                                    createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                    awardExperience(5);
                                }
                                projectile.life = 0; // Destroy projectile on hit
                            }
                        }
                    });
                    
                    if (projectile.life > 0) {
                        requestAnimationFrame(animateProjectile);
                    }
                };
                
                setTimeout(() => animateProjectile(), angle * 10);
            });
        }
        
        function executeMultiShot(target) {
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            SoundMixer.playWithVolume('multi_shot', 'effects');
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const projectile = {
                    x: target.x + target.width/2,
                    y: target.y + 20,
                    velocityX: Math.cos(rad) * 8,
                    velocityY: Math.sin(rad) * 8,
                    life: 60,
                    damage: 25
                };
                
                // Animate projectile
                const animateProjectile = () => {
                    if (projectile.life <= 0) return;
                    projectile.x += projectile.velocityX;
                    projectile.y += projectile.velocityY;
                    projectile.life--;
                    
                    // Draw projectile
                    ctx.save();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Check collision with player
                    const distance = Math.sqrt(
                        Math.pow(player.x + player.width/2 - projectile.x, 2) +
                        Math.pow(player.y + player.height/2 - projectile.y, 2)
                    );
                    if (distance < 20) {
                        player.health -= projectile.damage;
                        player.health = Math.max(0, player.health);
                        
                        if (player.health <= 0) {
                            createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                        } else {
                            createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                        }
                        projectile.life = 0; // Destroy projectile on hit
                    }
                    
                    if (projectile.life > 0) {
                        requestAnimationFrame(animateProjectile);
                    }
                };
                
                setTimeout(() => animateProjectile(), angle * 10);
            });
        }
        
        function timeField() {
            // Create time field effect
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = player.x + player.width/2 + Math.cos(angle) * 100;
                const y = player.y + player.height/2 + Math.sin(angle) * 100;
                particlePool.create(x, y, 'spawn');
            }
            
            SoundMixer.playWithVolume('time_field', 'effects');
            
            // Slow all enemies
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive && target.health > 0) {
                    target.slowed = true;
                    target.slowTimer = CONFIG.SLOW_DURATION;
                    target.speed *= 0.3;
                }
            });
        }
        
        function executeTimeField(target) {
            // Create time field effect
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = target.x + target.width/2 + Math.cos(angle) * 100;
                const y = target.y + target.height/2 + Math.sin(angle) * 100;
                particlePool.create(x, y, 'spawn');
            }
            
            SoundMixer.playWithVolume('time_field', 'effects');
            
            // Slow player
            player.slowed = true;
            player.slowTimer = CONFIG.SLOW_DURATION;
            player.speed *= 0.3;
        }
        
        function uppercut() {
            // Create upward effect
            for (let i = 0; i < 15; i++) {
                particlePool.create(player.x + player.width/2, player.y, 'spawn');
            }
            
            SoundMixer.playWithVolume('uppercut', 'effects');
            
            // Damage and launch nearby enemies
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive && target.health > 0) {
                    const distance = Math.abs(target.x - player.x);
                    if (distance < 80) {
                        target.health -= 35;
                        target.health = Math.max(0, target.health);
                        target.velocityY = -20; // Strong launch
                        target.velocityX = (target.x < player.x ? -10 : 10);
                        
                        if (target.health <= 0 && target.alive) {
                            target.alive = false;
                            createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            awardExperience(20, true);
                        } else {
                            createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            awardExperience(5);
                        }
                    }
                }
            });
        }
        
        function executeUppercut(target) {
            // Create upward effect
            for (let i = 0; i < 15; i++) {
                particlePool.create(target.x + target.width/2, target.y, 'spawn');
            }
            
            SoundMixer.playWithVolume('uppercut', 'effects');
            
            // Damage and launch player
            const distance = Math.abs(player.x - target.x);
            if (distance < 80) {
                player.health -= 35;
                player.health = Math.max(0, player.health);
                player.velocityY = -20;
                player.velocityX = (player.x < target.x ? -10 : 10);
                
                if (player.health <= 0) {
                    createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                } else {
                    createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                }
            }
        }
        
        function fireball() {
            SoundMixer.playWithVolume('fireball', 'effects');
            
            // Create fireball projectile
            const direction = player.facing === 'right' ? 1 : -1;
            const fireball = {
                x: player.x + player.width/2,
                y: player.y + 20,
                velocityX: direction * 10,
                velocityY: 0,
                life: 100,
                damage: 40
            };
            
            // Animate fireball
            const animateFireball = () => {
                if (fireball.life <= 0) return;
                fireball.x += fireball.velocityX;
                fireball.y += fireball.velocityY;
                fireball.life--;
                
                // Draw fireball
                ctx.save();
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.arc(fireball.x, fireball.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Add fire particles
                if (Math.random() < 0.3) {
                    particlePool.create(fireball.x, fireball.y, 'death');
                }
                ctx.restore();
                
                // Check collision with targets
                const targets = isOnlineMode ? [player2] : enemies;
                targets.forEach(target => {
                    if (target.alive && target.health > 0) {
                        const distance = Math.sqrt(
                            Math.pow(target.x + target.width/2 - fireball.x, 2) +
                            Math.pow(target.y + target.height/2 - fireball.y, 2)
                        );
                        if (distance < 20) {
                            target.health -= fireball.damage;
                            target.health = Math.max(0, target.health);
                            
                            // Explosion effect
                            for (let i = 0; i < 15; i++) {
                                particlePool.create(fireball.x, fireball.y, 'death');
                            }
                            
                            if (target.health <= 0 && target.alive) {
                                target.alive = false;
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                awardExperience(20, true);
                            } else {
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                awardExperience(5);
                            }
                            fireball.life = 0; // Destroy fireball on hit
                        }
                    }
                });
                
                // Boundary check
                if (fireball.x < 0 || fireball.x > canvas.width) {
                    fireball.life = 0;
                }
                
                if (fireball.life > 0) {
                    requestAnimationFrame(animateFireball);
                }
            };
            
            animateFireball();
        }
        
        function executeFireball(target) {
            SoundMixer.playWithVolume('fireball', 'effects');
            
            // Create fireball projectile
            const direction = target.facing === 'right' ? 1 : -1;
            const fireball = {
                x: target.x + target.width/2,
                y: target.y + 20,
                velocityX: direction * 10,
                velocityY: 0,
                life: 100,
                damage: 40
            };
            
            // Animate fireball
            const animateFireball = () => {
                if (fireball.life <= 0) return;
                fireball.x += fireball.velocityX;
                fireball.y += fireball.velocityY;
                fireball.life--;
                
                // Draw fireball
                ctx.save();
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.arc(fireball.x, fireball.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Add fire particles
                if (Math.random() < 0.3) {
                    particlePool.create(fireball.x, fireball.y, 'death');
                }
                ctx.restore();
                
                // Check collision with player
                const distance = Math.sqrt(
                    Math.pow(player.x + player.width/2 - fireball.x, 2) +
                    Math.pow(player.y + player.height/2 - fireball.y, 2)
                );
                if (distance < 20) {
                    player.health -= fireball.damage;
                    player.health = Math.max(0, player.health);
                    
                    // Explosion effect
                    for (let i = 0; i < 15; i++) {
                        particlePool.create(fireball.x, fireball.y, 'death');
                    }
                    
                    if (player.health <= 0) {
                        createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                    } else {
                        createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                    }
                    fireball.life = 0; // Destroy fireball on hit
                }
                
                // Boundary check
                if (fireball.x < 0 || fireball.x > canvas.width) {
                    fireball.life = 0;
                }
                
                if (fireball.life > 0) {
                    requestAnimationFrame(animateFireball);
                }
            };
            
            animateFireball();
        }
        
        function berserkerRage() {
            SoundMixer.playWithVolume('berserker_rage', 'effects');
            
            // Visual effect
            for (let i = 0; i < 30; i++) {
                particlePool.create(player.x + player.width/2, player.y + player.height/2, 'death');
            }
            
            // Temporary damage boost
            const originalDamage = player.damageMultiplier;
            player.damageMultiplier *= 2;
            
            // Visual indicator
            player.color = '#ff0000';
            
            setTimeout(() => {
                player.damageMultiplier = originalDamage;
                player.color = selectedCharacter.color;
            }, 5000);
        }
        
        function executeBerserkerRage(target) {
            SoundMixer.playWithVolume('berserker_rage', 'effects');
            
            // Visual effect
            for (let i = 0; i < 30; i++) {
                particlePool.create(target.x + target.width/2, target.y + target.height/2, 'death');
            }
            
            // Temporary damage boost for opponent
            // (This would be handled on the opponent's client in a real implementation)
        }
        
        function laserBeam() {
            const beamWidth = 20;
            const beamLength = canvas.width;
            const startX = player.facing === 'right' ? player.x + player.width : player.x;
            const endX = player.facing === 'right' ? canvas.width : 0;
            
            SoundMixer.playWithVolume('laser_beam', 'effects');
            
            // Animate laser sweep
            let sweepProgress = 0;
            const sweepSpeed = 0.05;
            
            const animateLaser = () => {
                if (sweepProgress >= 1) return;
                sweepProgress += sweepSpeed;
                
                // Draw laser
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(startX, player.y + 20, (endX - startX) * sweepProgress, beamWidth);
                ctx.restore();
                
                // Create laser particles
                for (let i = 0; i < 3; i++) {
                    const x = startX + (endX - startX) * sweepProgress;
                    const y = player.y + 20 + Math.random() * beamWidth;
                    particlePool.create(x, y, 'death');
                }
                
                // Check collision with targets
                const targets = isOnlineMode ? [player2] : enemies;
                targets.forEach(target => {
                    if (target.alive && target.health > 0) {
                        const targetCenterX = target.x + target.width/2;
                        const targetCenterY = target.y + target.height/2;
                        if (targetCenterX >= startX && targetCenterX <= startX + (endX - startX) * sweepProgress && 
                            targetCenterY >= player.y + 20 && targetCenterY <= player.y + 20 + beamWidth) {
                            target.health -= 2; // Continuous damage
                            target.health = Math.max(0, target.health);
                            
                            if (target.health <= 0 && target.alive) {
                                target.alive = false;
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                awardExperience(20, true);
                            } else {
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                awardExperience(1);
                            }
                        }
                    }
                });
                
                requestAnimationFrame(animateLaser);
            };
            
            animateLaser();
        }
        
        function executeLaserBeam(target) {
            const beamWidth = 20;
            const beamLength = canvas.width;
            const startX = target.facing === 'right' ? target.x + target.width : target.x;
            const endX = target.facing === 'right' ? canvas.width : 0;
            
            SoundMixer.playWithVolume('laser_beam', 'effects');
            
            // Animate laser sweep
            let sweepProgress = 0;
            const sweepSpeed = 0.05;
            
            const animateLaser = () => {
                if (sweepProgress >= 1) return;
                sweepProgress += sweepSpeed;
                
                // Draw laser
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(startX, target.y + 20, (endX - startX) * sweepProgress, beamWidth);
                ctx.restore();
                
                // Create laser particles
                for (let i = 0; i < 3; i++) {
                    const x = startX + (endX - startX) * sweepProgress;
                    const y = target.y + 20 + Math.random() * beamWidth;
                    particlePool.create(x, y, 'death');
                }
                
                // Check collision with player
                const playerCenterX = player.x + player.width/2;
                const playerCenterY = player.y + player.height/2;
                if (playerCenterX >= startX && playerCenterX <= startX + (endX - startX) * sweepProgress && 
                    playerCenterY >= target.y + 20 && playerCenterY <= target.y + 20 + beamWidth) {
                    player.health -= 2; // Continuous damage
                    player.health = Math.max(0, player.health);
                    
                    if (player.health <= 0) {
                        createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                    } else {
                        createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                    }
                }
                
                requestAnimationFrame(animateLaser);
            };
            
            animateLaser();
        }
        
        function arrowRain() {
            SoundMixer.playWithVolume('arrow_rain', 'effects');
            
            // Create multiple arrows falling from the sky
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const arrowX = Math.random() * canvas.width;
                    const arrow = {
                        x: arrowX,
                        y: -20,
                        velocityY: 12,
                        damage: 15,
                        life: 200
                    };
                    
                    const animateArrow = () => {
                        if (arrow.life <= 0) return;
                        arrow.y += arrow.velocityY;
                        arrow.life--;
                        
                        // Draw arrow
                        ctx.save();
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.moveTo(arrow.x, arrow.y);
                        ctx.lineTo(arrow.x - 3, arrow.y + 10);
                        ctx.lineTo(arrow.x, arrow.y + 8);
                        ctx.lineTo(arrow.x + 3, arrow.y + 10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                        
                        // Check collision with targets
                        const targets = isOnlineMode ? [player2] : enemies;
                        targets.forEach(target => {
                            if (target.alive && target.health > 0) {
                                const distance = Math.sqrt(
                                    Math.pow(target.x + target.width/2 - arrow.x, 2) +
                                    Math.pow(target.y + target.height/2 - arrow.y, 2)
                                );
                                if (distance < 20) {
                                    target.health -= arrow.damage;
                                    target.health = Math.max(0, target.health);
                                    
                                    if (target.health <= 0 && target.alive) {
                                        target.alive = false;
                                        createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                        awardExperience(20, true);
                                    } else {
                                        createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                        awardExperience(5);
                                    }
                                    arrow.life = 0; // Destroy arrow on hit
                                }
                            }
                        });
                        
                        if (arrow.life > 0 && arrow.y < canvas.height + 50) {
                            requestAnimationFrame(animateArrow);
                        }
                    };
                    
                    animateArrow();
                }, i * 100);
            }
        }
        
        function executeArrowRain(target) {
            SoundMixer.playWithVolume('arrow_rain', 'effects');
            
            // Create multiple arrows falling from the sky
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const arrowX = Math.random() * canvas.width;
                    const arrow = {
                        x: arrowX,
                        y: -20,
                        velocityY: 12,
                        damage: 15,
                        life: 200
                    };
                    
                    const animateArrow = () => {
                        if (arrow.life <= 0) return;
                        arrow.y += arrow.velocityY;
                        arrow.life--;
                        
                        // Draw arrow
                        ctx.save();
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.moveTo(arrow.x, arrow.y);
                        ctx.lineTo(arrow.x - 3, arrow.y + 10);
                        ctx.lineTo(arrow.x, arrow.y + 8);
                        ctx.lineTo(arrow.x + 3, arrow.y + 10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                        
                        // Check collision with player
                        const distance = Math.sqrt(
                            Math.pow(player.x + player.width/2 - arrow.x, 2) +
                            Math.pow(player.y + player.height/2 - arrow.y, 2)
                        );
                        if (distance < 20) {
                            player.health -= arrow.damage;
                            player.health = Math.max(0, player.health);
                            
                            if (player.health <= 0) {
                                createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                            } else {
                                createDeathEffect(player.x + player.width/2, player.y + player.height/2);
                            }
                            arrow.life = 0; // Destroy arrow on hit
                        }
                        
                        if (arrow.life > 0 && arrow.y < canvas.height + 50) {
                            requestAnimationFrame(animateArrow);
                        }
                    };
                    
                    animateArrow();
                }, i * 100);
            }
        }
        
        // Add a safe health update function
        function updateHealth(character, amount) {
            // Calculate new health
            const newHealth = character.health + amount;
            
            // Ensure health stays within bounds
            character.health = Math.max(0, Math.min(character.maxHealth, newHealth));
            
            // Only update health bars when there's a significant change
            if (Math.abs(amount) > 0.5) {
                updateHealthBars();
            }
        }
        
        function heal() {
            SoundMixer.playWithVolume('heal', 'effects');
            
            // Heal player using the safe health update
            updateHealth(player, 40);
            
            // Visual effect
            for (let i = 0; i < 20; i++) {
                particlePool.create(player.x + player.width/2, player.y + player.height/2, 'spawn');
            }
            
            // Temporary damage boost
            const originalDamage = player.damageMultiplier;
            player.damageMultiplier *= 1.5;
            
            setTimeout(() => {
                player.damageMultiplier = originalDamage;
            }, 3000);
        }
        
        function executeHeal(target) {
            // This would be handled on the opponent's client in a real implementation
        }
        
        // Update functions
        function updatePlayer(character) {
            if (!character.isLocalPlayer) return;
            
            // Update combo timer
            if (character.combo && character.combo.timer > 0) {
                character.combo.timer--;
            } else if (character.combo) {
                character.combo.count = 0;
                character.combo.multiplier = 1;
                updateComboDisplay();
            }
            
            // Handle stun effect
            if (character.stunned) {
                character.stunTimer--;
                if (character.stunTimer <= 0) {
                    character.stunned = false;
                }
                return; // Don't allow movement when stunned
            }
            
            // Movement
            if (keys['a']) {
                character.velocityX = -character.speed;
                character.facing = 'left';
            } else if (keys['d']) {
                character.velocityX = character.speed;
                character.facing = 'right';
            } else {
                character.velocityX *= 0.8;
            }
            
            // Jump
            if (keys['w'] && character.y >= CONFIG.GROUND_Y) {
                character.velocityY = -character.jumpPower;
                SoundMixer.playWithVolume('jump', 'effects');
            }
            
            // Special attack
            if (keys['q']) {
                useSpecialAttack();
            }
            
            // Attacks
            if (character.attackCooldown <= 0) {
                if (keys[' ']) {
                    character.isAttacking = true;
                    character.attackType = 'punch';
                    character.attackCooldown = 30;
                    character.attackFrame = 0;
                    
                    SoundMixer.playWithVolume('punch', 'effects');
                    
                    // Add charge (1.5x rate)
                    if (character.charge < character.maxCharge) {
                        character.charge += 15;
                    }
                    
                    // Check collision with all targets
                    const targets = isOnlineMode ? [player2] : enemies;
                    targets.forEach(target => {
                        if (target.alive && target.health > 0) {
                            const damageMultiplier = character.combo && character.combo.multiplier ? character.combo.multiplier : 1;
                            checkAttackCollision(character, target, 15 * character.damageMultiplier * damageMultiplier);
                        }
                    });
                } else if (keys['f']) {
                    character.isAttacking = true;
                    character.attackType = 'kick';
                    character.attackCooldown = 40;
                    character.attackFrame = 0;
                    
                    SoundMixer.playWithVolume('kick', 'effects');
                    
                    // Add charge (1.5x rate)
                    if (character.charge < character.maxCharge) {
                        character.charge += 23;
                    }
                    
                    // Check collision with all targets
                    const targets = isOnlineMode ? [player2] : enemies;
                    targets.forEach(target => {
                        if (target.alive && target.health > 0) {
                            const damageMultiplier = character.combo && character.combo.multiplier ? character.combo.multiplier : 1;
                            checkAttackCollision(character, target, 20 * character.damageMultiplier * damageMultiplier);
                        }
                    });
                }
            } else {
                character.attackCooldown--;
                character.attackFrame++;
                if (character.attackCooldown <= 20) {
                    character.isAttacking = false;
                    character.attackType = null;
                }
            }
            
            // Update special cooldown
            if (character.specialCooldown > 0) {
                character.specialCooldown--;
            }
            
            // Physics
            character.velocityY += CONFIG.GRAVITY;
            character.x += character.velocityX;
            character.y += character.velocityY;
            
            // Boundaries
            if (character.x < 0) character.x = 0;
            if (character.x + character.width > canvas.width) character.x = canvas.width - character.width;
            if (character.y > CONFIG.GROUND_Y) {
                character.y = CONFIG.GROUND_Y;
                character.velocityY = 0;
            }
            
            // Send game state to server if online
            if (isOnlineMode && socket && character.isLocalPlayer) {
                socket.emit('gameState', {
                    roomId: roomId,
                    x: character.x,
                    y: character.y,
                    velocityX: character.velocityX,
                    velocityY: character.velocityY,
                    facing: character.facing,
                    isAttacking: character.isAttacking,
                    attackType: character.attackType,
                    health: character.health,
                    isUsingSpecial: character.isUsingSpecial
                });
            }
        }
        
        function updateEnemy(enemy) {
            if (!enemy.alive) return;
            
            // Update slow effect
            if (enemy.slowed) {
                enemy.slowTimer--;
                if (enemy.slowTimer <= 0) {
                    enemy.slowed = false;
                    // Reset speed based on difficulty
                    if (gameMode === 'classic' && gameDifficulty === 'hard') {
                        enemy.speed = 4.5;
                    } else {
                        enemy.speed = 3;
                    }
                }
            }
            
            // Handle stun effect
            if (enemy.stunned) {
                enemy.stunTimer--;
                if (enemy.stunTimer <= 0) {
                    enemy.stunned = false;
                }
                return; // Don't allow movement when stunned
            }
            
            // AI Decision Making
            if (enemy.aiCooldown <= 0) {
                const distance = Math.abs(player.x - enemy.x);
                enemy.aiDecision = Math.random();
                
                if (distance > 150) {
                    // Move towards player
                    if (player.x < enemy.x) {
                        enemy.velocityX = -enemy.speed;
                        enemy.facing = 'left';
                    } else {
                        enemy.velocityX = enemy.speed;
                        enemy.facing = 'right';
                    }
                } else if (distance < 80) {
                    // Move away if too close
                    if (player.x < enemy.x) {
                        enemy.velocityX = enemy.speed;
                        enemy.facing = 'right';
                    } else {
                        enemy.velocityX = -enemy.speed;
                        enemy.facing = 'left';
                    }
                } else {
                    enemy.velocityX *= 0.8;
                }
                
                // Attack decision
                if (distance < 100 && enemy.attackCooldown <= 0) {
                    if (enemy.aiDecision < 0.6) {
                        enemy.isAttacking = true;
                        enemy.attackType = 'punch';
                        enemy.attackCooldown = 35;
                        enemy.attackFrame = 0;
                        SoundMixer.playWithVolume('enemy_punch', 'effects');
                        checkAttackCollision(enemy, player, 15 * (enemy.damageMultiplier || 1));
                    } else {
                        enemy.isAttacking = true;
                        enemy.attackType = 'kick';
                        enemy.attackCooldown = 45;
                        enemy.attackFrame = 0;
                        SoundMixer.playWithVolume('enemy_kick', 'effects');
                        checkAttackCollision(enemy, player, 20 * (enemy.damageMultiplier || 1));
                    }
                }
                
                // Jump decision
                if (enemy.aiDecision < 0.1 && enemy.y >= CONFIG.GROUND_Y) {
                    enemy.velocityY = -enemy.jumpPower;
                }
                
                enemy.aiCooldown = 30;
            } else {
                enemy.aiCooldown--;
            }
            
            // Physics
            enemy.velocityY += CONFIG.GRAVITY;
            enemy.x += enemy.velocityX;
            enemy.y += enemy.velocityY;
            
            // Boundaries
            if (enemy.x < 0) enemy.x = 0;
            if (enemy.x + enemy.width > canvas.width) enemy.x = canvas.width - enemy.width;
            if (enemy.y > CONFIG.GROUND_Y) {
                enemy.y = CONFIG.GROUND_Y;
                enemy.velocityY = 0;
            }
            
            // Attack cooldown
            if (enemy.attackCooldown > 0) {
                enemy.attackCooldown--;
                enemy.attackFrame++;
                if (enemy.attackCooldown <= 25) {
                    enemy.isAttacking = false;
                    enemy.attackType = null;
                }
            }
        }
        
        function checkAttackCollision(attacker, defender, damage) {
            const distance = Math.abs(attacker.x - defender.x);
            const range = attacker.attackRange || 60;
            if (distance < range && Math.abs(attacker.y - defender.y) < 50) {
                // Use the safe health update for damage
                updateHealth(defender, -damage);
                
                // Update combo for attacker
                if (defender.health > 0 && attacker.combo) {
                    attacker.combo.count++;
                    attacker.combo.timer = 120; // 2 seconds to continue combo
                    attacker.combo.multiplier = 1 + (attacker.combo.count * 0.1); // 10% damage increase per combo
                    updateComboDisplay();
                    checkAchievements();
                }
                
                // Handle death
                if (defender.health <= 0 && defender.alive) {
                    if (defender !== player && defender !== player2) {
                        defender.alive = false;
                        createDeathEffect(defender.x + defender.width/2, defender.y + defender.height/2);
                        awardExperience(20, true);
                    }
                } else if (defender.health > 0) {
                    awardExperience(5);
                }
                
                // Knockback
                const knockback = attacker.facing === 'right' ? 10 : -10;
                defender.velocityX = knockback;
                defender.velocityY = -5;
                
                SoundMixer.playWithVolume('hit', 'effects');
            }
        }
        
        function updatePowerUps() {
            powerUps.forEach((powerUp, index) => {
                if (!powerUp.collected) {
                    // Simple collision detection
                    const distance = Math.sqrt(
                        Math.pow(player.x + player.width/2 - (powerUp.x + powerUp.width/2), 2) +
                        Math.pow(player.y + player.height/2 - (powerUp.y + powerUp.height/2), 2)
                    );
                    
                    if (distance < 30) {
                        powerUp.collected = true;
                        applyPowerUp(powerUp.type);
                        createPowerUpEffect(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2);
                        powerUps.splice(index, 1);
                    }
                }
            });
        }
        
        function applyPowerUp(type) {
            switch(type) {
                case 'health':
                    updateHealth(player, 30);
                    break;
                case 'speed':
                    player.speedBoost = true;
                    const originalSpeed = player.speed;
                    player.speed *= 1.5;
                    setTimeout(() => {
                        player.speed = originalSpeed;
                        player.speedBoost = false;
                    }, 5000);
                    break;
                case 'damage':
                    player.damageBoost = true;
                    const originalDamage = player.damageMultiplier;
                    player.damageMultiplier *= 1.5;
                    setTimeout(() => {
                        player.damageMultiplier = originalDamage;
                        player.damageBoost = false;
                    }, 5000);
                    break;
                case 'charge':
                    player.charge = Math.min(player.maxCharge, player.charge + 50);
                    break;
            }
            updateHealthBars();
        }
        
        function updateComboDisplay() {
            const comboDisplay = document.getElementById('comboDisplay');
            if (player.combo && player.combo.count > 1) {
                comboDisplay.textContent = `COMBO: ${player.combo.count}x`;
                comboDisplay.style.display = 'block';
                // Add animation effect
                comboDisplay.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    comboDisplay.style.transform = 'scale(1)';
                }, 200);
            } else {
                comboDisplay.style.display = 'none';
            }
        }
        
        function awardExperience(amount, isKill = false) {
            player.experience += amount;
            if (player.experience >= player.expToNextLevel) {
                levelUp();
            }
            updateUI();
        }
        
        function levelUp() {
            player.level++;
            player.experience -= player.expToNextLevel;
            player.expToNextLevel = Math.floor(player.expToNextLevel * 1.5);
            
            // Store old max health
            const oldMaxHealth = player.maxHealth;
            
            // Stat increases
            player.maxHealth += 10;
            player.damageMultiplier += 0.1;
            
            // Increase health proportionally
            const healthPercentage = player.health / oldMaxHealth;
            player.health = Math.min(player.maxHealth, Math.max(player.health, player.maxHealth * healthPercentage));
            
            // Visual feedback
            document.getElementById('levelDisplay').textContent = `Level ${player.level}`;
            document.getElementById('levelDisplay').style.display = 'block';
            setTimeout(() => {
                document.getElementById('levelDisplay').style.display = 'none';
            }, 3000);
            
            SoundMixer.playWithVolume('level_up', 'effects');
            
            // Update health bars after level up
            updateHealthBars();
        }
        
        function updateUI() {
            document.getElementById('levelDisplay').textContent = `Level ${player.level}`;
        }
        
        function updateHealthBars() {
            document.getElementById('playerHealth').style.width = `${(player.health / player.maxHealth) * 100}%`;
            if (isOnlineMode) {
                document.getElementById('player2Health').style.width = `${(player2.health / player2.maxHealth) * 100}%`;
            } else if (gameMode === 'classic' && enemies.length > 0) {
                document.getElementById('cpuHealth').style.width = `${(enemies[0].health / enemies[0].maxHealth) * 100}%`;
            }
            
            // Update charge bar
            document.getElementById('chargeFill').style.width = `${(player.charge / player.maxCharge) * 100}%`;
        }
        
        function spawnEnemiesContinuously() {
            if (gameMode === 'survival' && gameRunning) {
                setTimeout(() => {
                    if (gameRunning) {
                        const x = Math.random() > 0.5 ? -50 : canvas.width + 50;
                        enemies.push(createEnemy(x));
                        spawnEnemiesContinuously();
                    }
                }, 3000 - Math.min(2500, Math.floor((Date.now() - survivalStartTime) / 1000) * 100)); // Increase spawn rate over time
            }
        }
        
        function showAchievementNotification(achievement) {
            const notification = document.getElementById('achievementNotification');
            document.getElementById('achievementName').textContent = achievement.name;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
            
            SoundMixer.playWithVolume('achievement', 'effects');
        }
        
        function checkAchievements() {
            achievements.forEach(achievement => {
                if (!achievement.unlocked) {
                    switch(achievement.id) {
                        case 'first_win':
                            if (player.wins > 0) {
                                achievement.unlocked = true;
                                showAchievementNotification(achievement);
                            }
                            break;
                        case 'combo_master':
                            if (player.combo && player.combo.count >= 10) {
                                achievement.unlocked = true;
                                showAchievementNotification(achievement);
                            }
                            break;
                        case 'specialist':
                            if (specialAttackCount >= 50) {
                                achievement.unlocked = true;
                                showAchievementNotification(achievement);
                            }
                            break;
                        case 'survivor':
                            if (gameMode === 'survival' && (Date.now() - survivalStartTime) >= 300000) { // 5 minutes
                                achievement.unlocked = true;
                                showAchievementNotification(achievement);
                            }
                            break;
                    }
                }
            });
        }
        
        function gameLoop(timestamp) {
            if (!gameRunning) return;
            
            DEBUG.update(timestamp);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply screen shake
            screenShake.update();
            
            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, CONFIG.GROUND_Y + 60, canvas.width, 40);
            
            // Update and draw players
            updatePlayer(player);
            drawStickman(player, 'Player');
            
            if (isOnlineMode) {
                // Only update local player, remote player is updated via socket
                if (player2.isLocalPlayer) {
                    updatePlayer(player2);
                }
                drawStickman(player2, 'Player 2');
            } else {
                // Update and draw enemies
                enemies.forEach(enemy => {
                    updateEnemy(enemy);
                    if (enemy.alive) {
                        drawStickman(enemy, 'Enemy');
                    }
                });
                
                // Update and draw power-ups
                powerUps.forEach(powerUp => {
                    drawPowerUp(powerUp);
                });
                updatePowerUps();
            }
            
            // Update and draw particles
            particlePool.update();
            particlePool.draw();
            
            // Restore screen shake
            screenShake.restore();
            
            // Check game over
            checkGameOver();
            
            // Check achievements periodically
            if (Math.floor(timestamp / 1000) % 5 === 0) {
                checkAchievements();
            }
            
            // Removed automatic health bar update - it's now called only when health changes
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        function resetGame() {
            // Reset all game objects to initial state
            player = {
                x: 100, y: 300, width: 40, height: 60,
                velocityX: 0, velocityY: 0, speed: 5, jumpPower: 15,
                health: 100, maxHealth: 100, isAttacking: false,
                attackType: null, attackCooldown: 0, attackFrame: 0,
                facing: 'right', color: '#4CAF50', accessories: [],
                damageMultiplier: 1.0, attackRange: 60, charge: 0,
                maxCharge: 100, specialCooldown: 0, isUsingSpecial: false,
                isLocalPlayer: true, stunned: false, stunTimer: 0,
                combo: { count: 0, timer: 0, multiplier: 1 },
                level: 1, experience: 0, expToNextLevel: 100, wins: player.wins || 0
            };
            
            player2 = {
                x: 600, y: 300, width: 40, height: 60,
                velocityX: 0, velocityY: 0, speed: 5, jumpPower: 15,
                health: 100, maxHealth: 100, isAttacking: false,
                attackType: null, attackCooldown: 0, attackFrame: 0,
                facing: 'left', color: '#4444ff', accessories: [],
                damageMultiplier: 1.0, attackRange: 60, charge: 0,
                maxCharge: 100, specialCooldown: 0, isUsingSpecial: false,
                isLocalPlayer: false, stunned: false, stunTimer: 0,
                combo: { count: 0, timer: 0, multiplier: 1 }
            };
            
            enemies = [];
            powerUps = [];
            particlePool.clear();
            specialAttackCount = 0;
        }
        
        function calculateCoinsEarned(won, gameMode, survivalTime) {
            let coinsEarned = 0;
            
            // Base coins for playing
            coinsEarned += 10;
            
            // Bonus for winning
            if (won) {
                coinsEarned += 25;
            }
            
            // Bonus for survival mode
            if (gameMode === 'survival' && survivalTime) {
                coinsEarned += Math.floor(survivalTime / 10); // 1 coin per 10 seconds
            }
            
            // Bonus for difficulty
            if (gameMode === 'classic' && gameDifficulty === 'hard') {
                coinsEarned += 15;
            }
            
            return coinsEarned;
        }
        
        function showCoinReward(coinsEarned) {
            document.getElementById('coinAmount').textContent = `+${coinsEarned}`;
            document.getElementById('coinReward').style.display = 'block';
        }
        
        function closeCoinReward() {
            document.getElementById('coinReward').style.display = 'none';
        }
        
        function startGame(mode, difficulty = 'normal') {
            gameMode = mode;
            gameDifficulty = difficulty;
            isOnlineMode = false;
            
            if (mode === 'classic') {
                document.getElementById('difficultySelection').style.display = 'none';
            } else {
                document.getElementById('modeSelection').style.display = 'none';
            }
            
            gameRunning = true;
            currentGameState = GameState.PLAYING;
            
            // Reset game state
            resetGame();
            
            // Setup UI based on mode
            if (mode === 'classic') {
                document.getElementById('cpuHealthContainer').style.display = 'flex';
                document.getElementById('player2Info').style.display = 'none';
                enemies = [createEnemy(600, difficulty)];
            } else if (mode === 'survival') {
                document.getElementById('cpuHealthContainer').style.display = 'none';
                document.getElementById('player2Info').style.display = 'none';
                survivalStartTime = Date.now();
                spawnEnemiesContinuously();
            }
            
            // Apply selected character stats to player
            player.color = selectedCharacter.color;
            player.accessories = selectedCharacter.accessories;
            player.speed = selectedCharacter.stats.speed;
            player.health = selectedCharacter.stats.health;
            player.maxHealth = selectedCharacter.stats.health;
            player.damageMultiplier = selectedCharacter.stats.damage;
            player.attackRange = selectedCharacter.stats.range;
            player.charge = 0;
            player.specialCooldown = 0;
            player.stunned = false;
            player.stunTimer = 0;
            
            // Reset player position
            player.x = 100;
            player.y = CONFIG.GROUND_Y;
            player.velocityX = 0;
            player.velocityY = 0;
            player.isAttacking = false;
            player.attackType = null;
            player.attackCooldown = 0;
            player.attackFrame = 0;
            
            updateHealthBars();
            updateUI();
            gameLoop();
        }
        
        function startOnlineGame() {
            gameMode = 'online';
            isOnlineMode = true;
            gameRunning = true;
            currentGameState = GameState.PLAYING;
            
            // Reset game state
            resetGame();
            
            // Setup UI for online mode
            document.getElementById('cpuHealthContainer').style.display = 'none';
            document.getElementById('player2Info').style.display = 'flex';
            
            // Apply selected character stats to players
            player.color = selectedCharacter.color;
            player.accessories = selectedCharacter.accessories;
            player.speed = selectedCharacter.stats.speed;
            player.health = selectedCharacter.stats.health;
            player.maxHealth = selectedCharacter.stats.health;
            player.damageMultiplier = selectedCharacter.stats.damage;
            player.attackRange = selectedCharacter.stats.range;
            player.charge = 0;
            player.specialCooldown = 0;
            player.stunned = false;
            player.stunTimer = 0;
            
            player2.color = selectedCharacter.color; // Could be different in future
            player2.accessories = selectedCharacter.accessories;
            player2.speed = selectedCharacter.stats.speed;
            player2.health = selectedCharacter.stats.health;
            player2.maxHealth = selectedCharacter.stats.health;
            player2.damageMultiplier = selectedCharacter.stats.damage;
            player2.attackRange = selectedCharacter.stats.range;
            player2.charge = 0;
            player2.specialCooldown = 0;
            player2.stunned = false;
            player2.stunTimer = 0;
            
            // Reset player positions
            player.x = isPlayer1 ? 100 : 600;
            player.y = CONFIG.GROUND_Y;
            player.velocityX = 0;
            player.velocityY = 0;
            player.isAttacking = false;
            player.attackType = null;
            player.attackCooldown = 0;
            player.attackFrame = 0;
            player.facing = isPlayer1 ? 'right' : 'left';
            player.isLocalPlayer = true;
            
            player2.x = isPlayer1 ? 600 : 100;
            player2.y = CONFIG.GROUND_Y;
            player2.velocityX = 0;
            player2.velocityY = 0;
            player2.isAttacking = false;
            player2.attackType = null;
            player2.attackCooldown = 0;
            player2.attackFrame = 0;
            player2.facing = isPlayer1 ? 'left' : 'right';
            player2.isLocalPlayer = false;
            
            updateHealthBars();
            updateUI();
            gameLoop();
        }
        
        function checkGameOver() {
            if (player.health <= 0) {
                let message = '';
                let won = false;
                let coinsEarned = 0;
                
                if (gameMode === 'classic') {
                    message = gameDifficulty === 'hard' ? 'The Hard CPU was too strong!' : 'The CPU was too strong this time.';
                    coinsEarned = calculateCoinsEarned(false, gameMode);
                } else if (isOnlineMode) {
                    message = 'You lost the match!';
                    coinsEarned = calculateCoinsEarned(false, gameMode);
                } else if (gameMode === 'survival') {
                    const survivalTime = Math.floor((Date.now() - survivalStartTime) / 1000);
                    message = `You survived ${survivalTime} seconds!`;
                    coinsEarned = calculateCoinsEarned(false, gameMode, survivalTime);
                }
                
                addCoins(coinsEarned);
                showCoinReward(coinsEarned);
                endGame('Game Over', message);
            } else if (player2.health <= 0 && isOnlineMode) {
                player.wins++;
                const coinsEarned = calculateCoinsEarned(true, gameMode);
                addCoins(coinsEarned);
                showCoinReward(coinsEarned);
                endGame('You Win!', 'Congratulations! You defeated your opponent!');
            } else if (gameMode === 'classic' && enemies.length > 0 && enemies[0].health <= 0) {
                player.wins++;
                const coinsEarned = calculateCoinsEarned(true, gameMode);
                addCoins(coinsEarned);
                showCoinReward(coinsEarned);
                endGame('You Win!', 'Congratulations! You defeated the CPU!');
            }
        }
        
        function endGame(title, message) {
            gameRunning = false;
            currentGameState = GameState.GAME_OVER;
            
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            cancelAnimationFrame(animationId);
            document.getElementById('gameOverText').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOver').style.display = 'block';
            updateConnectionStatus(false);
            
            // Save game data including coins and unlocked characters
            saveGameData();
        }
        
        // Particle pool for better performance
        const particlePool = {
            particles: [],
            activeParticles: [],
            
            create: function(x, y, type = 'death') {
                let particle = this.particles.pop();
                if (!particle) {
                    particle = {
                        x: 0, y: 0, velocityX: 0, velocityY: 0, 
                        size: 0, life: 0, decay: 0, color: '', type
                    };
                }
                
                // Reset particle properties
                particle.x = x;
                particle.y = y;
                particle.velocityX = (Math.random() - 0.5) * 8;
                particle.velocityY = (Math.random() - 0.5) * 8;
                particle.size = Math.random() * 5 + 2;
                particle.life = 1.0;
                particle.decay = 0.02;
                particle.color = type === 'death' ? '#ff4444' : '#44ff44';
                particle.type = type;
                
                if (type === 'spawn') {
                    particle.velocityX *= 0.3;
                    particle.velocityY *= 0.3;
                    particle.decay = 0.01;
                } else if (type === 'powerup') {
                    particle.color = '#ffff00';
                    particle.decay = 0.03;
                }
                
                this.activeParticles.push(particle);
                return particle;
            },
            
            update: function() {
                for (let i = this.activeParticles.length - 1; i >= 0; i--) {
                    const particle = this.activeParticles[i];
                    particle.x += particle.velocityX;
                    particle.y += particle.velocityY;
                    particle.life -= particle.decay;
                    particle.velocityY += 0.2; // gravity
                    
                    if (particle.life <= 0) {
                        this.activeParticles.splice(i, 1);
                        this.particles.push(particle); // Return to pool
                    }
                }
            },
            
            draw: function() {
                this.activeParticles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            },
            
            clear: function() {
                this.activeParticles = [];
                // Return all particles to pool
                this.particles = this.particles.concat(this.activeParticles);
            }
        };
        
        // Sound manager (stub implementation)
        const SoundMixer = {
            volume: {
                master: 1.0,
                effects: 1.0,
                music: 1.0
            },
            
            setVolume: function(category, value) {
                this.volume[category] = Math.max(0, Math.min(1, value));
            },
            
            playWithVolume: function(sound, category) {
                const volume = this.volume.master * this.volume[category];
                console.log(`Playing ${sound} at volume ${volume}`);
            }
        };
        
        // Draw power-up function
        function drawPowerUp(powerUp) {
            ctx.save();
            ctx.fillStyle = powerUp.color;
            ctx.beginPath();
            ctx.arc(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, powerUp.width/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Initialize game
        window.onload = function() {
            loadGameData();
            updateCoinDisplay();
        };
    </script>
</body>
</html>
