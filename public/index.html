<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #90EE90 50%, #7CFC00 100%);
            border: 3px solid #333;
            border-radius: 10px;
            display: block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: white;
        }

        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-bar {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #333;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s ease;
            border-radius: 13px;
        }

        .health-fill.player {
            background: linear-gradient(90deg, #44ff44, #66ff66);
        }

        .health-fill.player2 {
            background: linear-gradient(90deg, #4444ff, #6666ff);
        }

        .wave-info {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        .lives {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .life {
            width: 20px;
            height: 20px;
            background: #ff4444;
            border-radius: 50%;
            border: 2px solid white;
        }

        .charge-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .charge-bar {
            width: 150px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
        }

        .charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ffdd00);
            transition: width 0.2s ease;
            border-radius: 8px;
        }

        .controls {
            margin-top: 15px;
            text-align: center;
            color: white;
            font-size: 14px;
        }

        .controls h3 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        .control-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 5px 0;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-weight: bold;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        .game-over h2 {
            font-size: 36px;
            margin-bottom: 15px;
        }

        .game-over button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .game-over button:hover {
            transform: scale(1.05);
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
        }

        .start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .start-screen button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 20px;
        }

        .start-screen button:hover {
            transform: scale(1.05);
        }

        .character-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 900px;
            width: 90%;
        }

        .character-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .character-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .character-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .character-card.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.3);
        }

        .character-preview {
            width: 100px;
            height: 120px;
            margin: 0 auto 15px;
            position: relative;
        }

        .character-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .character-stats {
            font-size: 14px;
            line-height: 1.6;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-bar {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-left: 10px;
        }

        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #44ff44, #66ff66);
            border-radius: 4px;
        }

        .start-button-container {
            margin-top: 30px;
            text-align: center;
        }

        #startGameBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin: 0 auto;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #startGameBtn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #startGameBtn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .selection-instruction {
            margin-bottom: 20px;
            font-size: 18px;
            color: #ccc;
        }

        .mode-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 600px;
        }

        .mode-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .mode-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 30px;
            font-size: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .mode-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .mode-description {
            margin-top: 20px;
            font-size: 16px;
            color: #ccc;
            line-height: 1.6;
        }

        .special-attack-info {
            margin-top: 10px;
            font-size: 12px;
            color: #ffaa00;
        }

        .difficulty-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 500px;
        }

        .difficulty-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .difficulty-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }

        .difficulty-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .difficulty-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .difficulty-description {
            margin-top: 20px;
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }

        .online-lobby {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            max-width: 500px;
        }

        .online-lobby h1 {
            font-size: 36px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lobby-status {
            font-size: 18px;
            margin-bottom: 20px;
            color: #ccc;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .cancel-button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .cancel-button:hover {
            background: #ff6666;
            transform: scale(1.05);
        }

        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        .connected {
            background: #44ff44;
            color: #000;
        }

        .disconnected {
            background: #ff4444;
            color: #fff;
        }

        .player2-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="connection-status disconnected" id="connectionStatus">Disconnected</div>
        
        <div class="game-info" id="gameInfo">
            <div class="health-bar-container">
                <span>Player 1</span>
                <div class="health-bar">
                    <div class="health-fill player" id="playerHealth"></div>
                </div>
            </div>
            <div class="player2-info" id="player2Info" style="display: none;">
                <span>Player 2</span>
                <div class="health-bar">
                    <div class="health-fill player2" id="player2Health"></div>
                </div>
            </div>
            <div class="wave-info" id="waveInfo" style="display: none;">
                <span>Wave: <span id="currentWave">1</span></span>
                <span>Enemies: <span id="enemiesLeft">1</span></span>
                <div class="lives" id="livesContainer"></div>
            </div>
            <div class="charge-bar-container">
                <span>Special</span>
                <div class="charge-bar">
                    <div class="charge-fill" id="chargeFill"></div>
                </div>
            </div>
            <div class="health-bar-container" id="cpuHealthContainer">
                <div class="health-bar">
                    <div class="health-fill cpu" id="cpuHealth"></div>
                </div>
                <span>CPU</span>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <div class="controls">
            <h3>Controls</h3>
            <div class="control-row">
                <span><span class="key">A</span> <span class="key">D</span> Move</span>
                <span><span class="key">W</span> Jump</span>
                <span><span class="key">Space</span> Punch</span>
                <span><span class="key">F</span> Kick</span>
                <span><span class="key">Q</span> Special</span>
            </div>
        </div>
    </div>

    <div class="start-screen" id="startScreen">
        <h1>Stickman Fighter</h1>
        <p>Choose your fighter and defeat the CPU opponent!</p>
        <button onclick="showCharacterSelection()">Choose Character</button>
    </div>

    <div class="character-selection" id="characterSelection">
        <h1>Select Your Fighter</h1>
        <p class="selection-instruction">Click on a character to select them</p>
        <div class="characters-grid" id="charactersGrid"></div>
        <div class="start-button-container">
            <button id="startGameBtn" disabled onclick="showModeSelection()">SELECT MODE</button>
        </div>
    </div>

    <div class="mode-selection" id="modeSelection">
        <h1>Select Game Mode</h1>
        <div class="mode-buttons">
            <button class="mode-button" onclick="showDifficultySelection()">Classic Mode</button>
            <button class="mode-button" onclick="startGame('wave')">Wave Mode</button>
            <button class="mode-button" onclick="enterOnlineMode()">Online Mode</button>
        </div>
        <div class="mode-description">
            <p><strong>Classic Mode:</strong> Fight against a single CPU opponent</p>
            <p><strong>Wave Mode:</strong> Survive waves of enemies with 3 lives!</p>
            <p><strong>Online Mode:</strong> Battle against other players online!</p>
        </div>
    </div>

    <div class="difficulty-selection" id="difficultySelection">
        <h1>Select Difficulty</h1>
        <div class="difficulty-buttons">
            <button class="difficulty-button" onclick="startGame('classic', 'normal')">Normal</button>
            <button class="difficulty-button" onclick="startGame('classic', 'hard')">Hard</button>
        </div>
        <div class="difficulty-description">
            <p><strong>Normal:</strong> Standard CPU opponent</p>
            <p><strong>Hard:</strong> Tougher CPU with more health and damage</p>
        </div>
    </div>

    <div class="online-lobby" id="onlineLobby">
        <h1>Online Mode</h1>
        <div class="lobby-status" id="lobbyStatus">Connecting to server...</div>
        <div class="loading-spinner"></div>
        <button class="cancel-button" onclick="cancelOnlineMode()">Cancel</button>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="gameOverText">Game Over</h2>
        <p id="gameOverMessage"></p>
        <button onclick="showCharacterSelection()">Play Again</button>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = false;
        let animationId;
        let selectedCharacter = null;
        let gameMode = 'classic';
        let gameDifficulty = 'normal';
        let currentWave = 1;
        let enemies = [];
        let particles = [];
        let playerLives = 3;
        let isRespawning = false;
        let isOnlineMode = false;
        let socket = null;
        let roomId = null;
        let isPlayer1 = true;
        let player2Data = null;
        
        // Character definitions with special attacks
        const characters = [
            {
                id: 'brawler',
                name: 'Brawler',
                color: '#ff4444',
                accessories: ['sunglasses'],
                stats: {
                    damage: 1.5,
                    speed: 4,
                    range: 60,
                    health: 100
                },
                specialAttack: 'groundSlam',
                specialDescription: 'Ground Slam - Stuns all enemies',
                description: 'High damage but slower'
            },
            {
                id: 'ninja',
                name: 'Ninja',
                color: '#4444ff',
                accessories: ['headband'],
                stats: {
                    damage: 0.8,
                    speed: 7,
                    range: 60,
                    health: 90
                },
                specialAttack: 'shadowDash',
                specialDescription: 'Shadow Dash - Teleport and damage',
                description: 'Fast but lower damage'
            },
            {
                id: 'cowboy',
                name: 'Cowboy',
                color: '#ffaa00',
                accessories: ['cowboy_hat'],
                stats: {
                    damage: 1.0,
                    speed: 5,
                    range: 80,
                    health: 100
                },
                specialAttack: 'multiShot',
                specialDescription: 'Multi Shot - Fires in all directions',
                description: 'Long range attacks'
            },
            {
                id: 'gentleman',
                name: 'Gentleman',
                color: '#aa44ff',
                accessories: ['top_hat', 'sunglasses'],
                stats: {
                    damage: 1.2,
                    speed: 5,
                    range: 70,
                    health: 110
                },
                specialAttack: 'timeField',
                specialDescription: 'Time Field - Slows enemies',
                description: 'Balanced with extra health'
            },
            {
                id: 'fighter',
                name: 'Fighter',
                color: '#4CAF50',
                accessories: [],
                stats: {
                    damage: 1.0,
                    speed: 5,
                    range: 60,
                    health: 100
                },
                specialAttack: 'uppercut',
                specialDescription: 'Uppercut - Launches enemies',
                description: 'Well-rounded fighter'
            },
            {
                id: 'robot',
                name: 'Robot',
                color: '#888888',
                accessories: ['antenna'],
                stats: {
                    damage: 1.3,
                    speed: 4.5,
                    range: 65,
                    health: 120
                },
                specialAttack: 'laserBeam',
                specialDescription: 'Laser Beam - Sweeping attack',
                description: 'Tank with high health'
            }
        ];
        
        // Game objects
        let player = {
            x: 100,
            y: 300,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: null,
            attackCooldown: 0,
            attackFrame: 0,
            facing: 'right',
            color: '#4CAF50',
            accessories: [],
            damageMultiplier: 1.0,
            attackRange: 60,
            charge: 0,
            maxCharge: 100,
            specialCooldown: 0,
            isUsingSpecial: false
        };
        
        let player2 = {
            x: 600,
            y: 300,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: null,
            attackCooldown: 0,
            attackFrame: 0,
            facing: 'left',
            color: '#4444ff',
            accessories: [],
            damageMultiplier: 1.0,
            attackRange: 60,
            charge: 0,
            maxCharge: 100,
            specialCooldown: 0,
            isUsingSpecial: false
        };
        
        function createEnemy(x = 600, difficulty = 'normal') {
            const enemy = {
                x: x,
                y: 300,
                width: 40,
                height: 60,
                velocityX: 0,
                velocityY: 0,
                speed: 3,
                jumpPower: 12,
                health: 100,
                maxHealth: 100,
                isAttacking: false,
                attackType: null,
                attackCooldown: 0,
                attackFrame: 0,
                facing: 'left',
                color: '#f44336',
                accessories: [],
                aiDecision: 0,
                aiCooldown: 0,
                alive: true,
                slowed: false,
                slowTimer: 0
            };
            
            // Apply difficulty modifiers
            if (difficulty === 'hard') {
                enemy.health = 150;
                enemy.maxHealth = 150;
                enemy.speed = 4.5;
                enemy.damageMultiplier = 1.5;
                enemy.attackRange = 70;
            }
            
            return enemy;
        }
        
        function createParticle(x, y, type = 'death') {
            const particle = {
                x: x,
                y: y,
                velocityX: (Math.random() - 0.5) * 8,
                velocityY: (Math.random() - 0.5) * 8,
                size: Math.random() * 5 + 2,
                life: 1.0,
                decay: 0.02,
                color: type === 'death' ? '#ff4444' : '#44ff44',
                type: type
            };
            
            if (type === 'spawn') {
                particle.velocityX *= 0.3;
                particle.velocityY *= 0.3;
                particle.decay = 0.01;
            }
            
            return particle;
        }
        
        const gravity = 0.8;
        const groundY = 300;
        
        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // Drawing functions
        function drawAccessory(character, accessory) {
            const centerX = character.x + character.width/2;
            const headY = character.y - 10;
            
            ctx.save();
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#333';
            ctx.lineWidth = 2;
            
            switch(accessory) {
                case 'sunglasses':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 12, headY - 2);
                    ctx.lineTo(centerX + 12, headY - 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(centerX - 6, headY - 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + 6, headY - 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'cowboy_hat':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 15, headY - 5);
                    ctx.lineTo(centerX + 15, headY - 5);
                    ctx.lineTo(centerX + 12, headY - 15);
                    ctx.lineTo(centerX - 12, headY - 15);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, headY - 5);
                    ctx.lineTo(centerX + 20, headY - 5);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                    
                case 'top_hat':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 10, headY - 20);
                    ctx.lineTo(centerX + 10, headY - 20);
                    ctx.lineTo(centerX + 8, headY - 5);
                    ctx.lineTo(centerX - 8, headY - 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(centerX - 15, headY - 5);
                    ctx.lineTo(centerX + 15, headY - 5);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;
                    
                case 'headband':
                    ctx.beginPath();
                    ctx.moveTo(centerX - 12, headY - 8);
                    ctx.lineTo(centerX + 12, headY - 8);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(centerX - 2, headY - 12, 4, 4);
                    break;
                    
                case 'antenna':
                    ctx.beginPath();
                    ctx.moveTo(centerX, headY - 10);
                    ctx.lineTo(centerX, headY - 20);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(centerX, headY - 22, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
            
            ctx.restore();
        }
        
        function drawStickman(character, label) {
            ctx.save();
            
            // Spawn effect
            if ((character === player || character === player2) && isRespawning) {
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.5;
            }
            
            // Body
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            // Head
            ctx.beginPath();
            ctx.arc(character.x + character.width/2, character.y - 10, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw accessories
            if (character.accessories) {
                character.accessories.forEach(accessory => {
                    drawAccessory(character, accessory);
                });
            }
            
            // Body
            ctx.beginPath();
            ctx.moveTo(character.x + character.width/2, character.y);
            ctx.lineTo(character.x + character.width/2, character.y + 30);
            ctx.stroke();
            
            // Arms
            const armAngle = character.isAttacking ? 0.5 : 0.2;
            const armOffset = Math.sin(Date.now() * 0.01) * 5;
            
            // Back arm (always normal)
            const backArmX = character.x + character.width/2 + (character.facing === 'right' ? -15 : 15);
            const backArmY = character.y + 20 - armOffset;
            ctx.beginPath();
            ctx.moveTo(character.x + character.width/2, character.y + 10);
            ctx.lineTo(backArmX, backArmY);
            ctx.stroke();
            
            // Front arm (changes during punch)
            if (character.isAttacking && character.attackType === 'punch') {
                // Punching animation - extend arm forward
                const punchExtension = 20 + Math.sin(character.attackFrame * 0.5) * 5;
                const punchX = character.x + character.width/2 + (character.facing === 'right' ? punchExtension : -punchExtension);
                const punchY = character.y + 10;
                
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 10);
                ctx.lineTo(punchX, punchY);
                ctx.stroke();
                
                // Fist
                ctx.fillStyle = character.color;
                ctx.beginPath();
                ctx.arc(punchX, punchY, 5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Normal arm
                const frontArmX = character.x + character.width/2 + (character.facing === 'right' ? 15 : -15);
                const frontArmY = character.y + 20 + armOffset;
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 10);
                ctx.lineTo(frontArmX, frontArmY);
                ctx.stroke();
            }
            
            // Legs
            const legOffset = Math.sin(Date.now() * 0.02) * 5;
            
            // Back leg (always normal)
            const backLegX = character.x + character.width/2 - 10;
            const backLegY = character.y + character.height + legOffset;
            ctx.beginPath();
            ctx.moveTo(character.x + character.width/2, character.y + 30);
            ctx.lineTo(backLegX, backLegY);
            ctx.stroke();
            
            // Front leg (changes during kick)
            if (character.isAttacking && character.attackType === 'kick') {
                // Kicking animation - extend leg forward
                const kickExtension = 25 + Math.sin(character.attackFrame * 0.4) * 8;
                const kickX = character.x + character.width/2 + (character.facing === 'right' ? kickExtension : -kickExtension);
                const kickY = character.y + 30;
                
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 30);
                ctx.lineTo(kickX, kickY);
                ctx.stroke();
                
                // Foot
                ctx.fillStyle = character.color;
                ctx.beginPath();
                ctx.arc(kickX, kickY, 6, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Normal leg
                const frontLegX = character.x + character.width/2 + 10;
                const frontLegY = character.y + character.height - legOffset;
                ctx.beginPath();
                ctx.moveTo(character.x + character.width/2, character.y + 30);
                ctx.lineTo(frontLegX, frontLegY);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function drawEnemyHealthBar(enemy) {
            if (!enemy.alive) return;
            
            const barWidth = 100; // Half the size of normal health bars
            const barHeight = 12;
            const x = enemy.x + enemy.width/2 - barWidth/2;
            const y = enemy.y - 30;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(x, y, barWidth, barHeight);
            
            // Border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, barWidth, barHeight);
            
            // Health fill
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.fillStyle = healthPercent > 0.5 ? '#44ff44' : healthPercent > 0.25 ? '#ffaa00' : '#ff4444';
            ctx.fillRect(x + 1, y + 1, (barWidth - 2) * healthPercent, barHeight - 2);
        }
        
        function drawParticles() {
            particles.forEach((particle, index) => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Update particle
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                particle.life -= particle.decay;
                particle.velocityY += 0.2; // gravity
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
        }
        
        function createDeathEffect(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push(createParticle(x, y, 'death'));
            }
        }
        
        function createSpawnEffect(x, y) {
            for (let i = 0; i < 15; i++) {
                particles.push(createParticle(x, y, 'spawn'));
            }
        }
        
        // Character selection functions
        function showCharacterSelection() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('characterSelection').style.display = 'block';
            
            const grid = document.getElementById('charactersGrid');
            grid.innerHTML = '';
            
            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.onclick = () => selectCharacter(char);
                
                const preview = document.createElement('div');
                preview.className = 'character-preview';
                
                const name = document.createElement('div');
                name.className = 'character-name';
                name.textContent = char.name;
                
                const stats = document.createElement('div');
                stats.className = 'character-stats';
                
                // Create stat bars
                const damageStat = createStat('Damage', char.stats.damage, 1.5);
                const speedStat = createStat('Speed', char.stats.speed, 7);
                const rangeStat = createStat('Range', char.stats.range, 80);
                const healthStat = createStat('Health', char.stats.health, 120);
                
                stats.appendChild(damageStat);
                stats.appendChild(speedStat);
                stats.appendChild(rangeStat);
                stats.appendChild(healthStat);
                
                const desc = document.createElement('div');
                desc.style.fontSize = '12px';
                desc.style.marginTop = '10px';
                desc.style.color = '#ccc';
                desc.textContent = char.description;
                
                const special = document.createElement('div');
                special.className = 'special-attack-info';
                special.textContent = char.specialDescription;
                
                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(stats);
                card.appendChild(desc);
                card.appendChild(special);
                grid.appendChild(card);
                
                // Draw character preview
                setTimeout(() => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 100;
                    canvas.height = 120;
                    preview.appendChild(canvas);
                    const ctx = canvas.getContext('2d');
                    
                    // Draw mini character
                    const miniChar = {
                        x: 30,
                        y: 60,
                        width: 40,
                        height: 60,
                        color: char.color,
                        accessories: char.accessories,
                        facing: 'right'
                    };
                    
                    ctx.strokeStyle = char.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(50, 50, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Accessories (mini version)
                    char.accessories.forEach(acc => {
                        drawMiniAccessory(ctx, 50, 50, acc);
                    });
                    
                    // Body
                    ctx.beginPath();
                    ctx.moveTo(50, 58);
                    ctx.lineTo(50, 78);
                    ctx.stroke();
                    
                    // Arms
                    ctx.beginPath();
                    ctx.moveTo(50, 63);
                    ctx.lineTo(40, 73);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(50, 63);
                    ctx.lineTo(60, 73);
                    ctx.stroke();
                    
                    // Legs
                    ctx.beginPath();
                    ctx.moveTo(50, 78);
                    ctx.lineTo(40, 98);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(50, 78);
                    ctx.lineTo(60, 98);
                    ctx.stroke();
                }, 10);
            });
        }
        
        function drawMiniAccessory(ctx, x, y, accessory) {
            ctx.save();
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#333';
            ctx.lineWidth = 1;
            
            switch(accessory) {
                case 'sunglasses':
                    ctx.fillRect(x - 8, y - 2, 16, 2);
                    ctx.beginPath();
                    ctx.arc(x - 4, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 4, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'cowboy_hat':
                    ctx.fillRect(x - 10, y - 15, 20, 10);
                    ctx.fillRect(x - 13, y - 5, 26, 2);
                    break;
                case 'top_hat':
                    ctx.fillRect(x - 6, y - 18, 12, 13);
                    ctx.fillRect(x - 10, y - 5, 20, 2);
                    break;
                case 'headband':
                    ctx.fillRect(x - 8, y - 8, 16, 2);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(x - 1, y - 11, 2, 3);
                    break;
                case 'antenna':
                    ctx.fillRect(x - 1, y - 10, 2, 10);
                    ctx.beginPath();
                    ctx.arc(x, y - 20, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
            
            ctx.restore();
        }
        
        function createStat(name, value, max) {
            const stat = document.createElement('div');
            stat.className = 'stat';
            
            const label = document.createElement('span');
            label.textContent = name;
            
            const bar = document.createElement('div');
            bar.className = 'stat-bar';
            
            const fill = document.createElement('div');
            fill.className = 'stat-fill';
            fill.style.width = `${(value / max) * 100}%`;
            
            bar.appendChild(fill);
            stat.appendChild(label);
            stat.appendChild(bar);
            
            return stat;
        }
        
        function selectCharacter(character) {
            selectedCharacter = character;
            
            // Update UI
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');
            
            // Enable start button
            const startBtn = document.getElementById('startGameBtn');
            startBtn.disabled = false;
            startBtn.textContent = 'SELECT MODE';
            
            // Scroll to button
            startBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        function showModeSelection() {
            if (!selectedCharacter) {
                alert('Please select a character first!');
                return;
            }
            
            document.getElementById('characterSelection').style.display = 'none';
            document.getElementById('modeSelection').style.display = 'block';
        }
        
        function showDifficultySelection() {
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('difficultySelection').style.display = 'block';
        }
        
        function enterOnlineMode() {
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('onlineLobby').style.display = 'block';
            connectToServer();
        }
        
        function cancelOnlineMode() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            document.getElementById('onlineLobby').style.display = 'none';
            document.getElementById('modeSelection').style.display = 'block';
            updateConnectionStatus(false);
        }
        
        function connectToServer() {
            socket = io('http://localhost:3000');
            
            socket.on('connect', () => {
                updateConnectionStatus(true);
                document.getElementById('lobbyStatus').textContent = 'Connected! Finding match...';
                socket.emit('findMatch');
            });
            
            socket.on('disconnect', () => {
                updateConnectionStatus(false);
            });
            
            socket.on('matchFound', (data) => {
                roomId = data.roomId;
                isPlayer1 = data.isPlayer1;
                document.getElementById('lobbyStatus').textContent = 'Match found! Starting game...';
                
                setTimeout(() => {
                    document.getElementById('onlineLobby').style.display = 'none';
                    startOnlineGame();
                }, 1000);
            });
            
            socket.on('playerJoined', (data) => {
                if (data.playerId !== socket.id) {
                    player2Data = data;
                }
            });
            
            socket.on('gameState', (data) => {
                if (data.playerId !== socket.id) {
                    // Update opponent state
                    if (isPlayer1) {
                        player2.x = data.x;
                        player2.y = data.y;
                        player2.velocityX = data.velocityX;
                        player2.velocityY = data.velocityY;
                        player2.facing = data.facing;
                        player2.isAttacking = data.isAttacking;
                        player2.attackType = data.attackType;
                        player2.health = data.health;
                        player2.isUsingSpecial = data.isUsingSpecial;
                    } else {
                        player.x = data.x;
                        player.y = data.y;
                        player.velocityX = data.velocityX;
                        player.velocityY = data.velocityY;
                        player.facing = data.facing;
                        player.isAttacking = data.isAttacking;
                        player.attackType = data.attackType;
                        player.health = data.health;
                        player.isUsingSpecial = data.isUsingSpecial;
                    }
                }
            });
            
            socket.on('specialAttack', (data) => {
                if (data.playerId !== socket.id) {
                    // Execute opponent's special attack
                    const opponent = isPlayer1 ? player2 : player;
                    executeSpecialAttack(data.attackType, opponent);
                }
            });
            
            socket.on('playerDisconnected', () => {
                endGame('Player Disconnected', 'Your opponent left the game');
            });
        }
        
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'Connected';
                status.className = 'connection-status connected';
            } else {
                status.textContent = 'Disconnected';
                status.className = 'connection-status disconnected';
            }
        }
        
        // Special attack functions
        function useSpecialAttack() {
            if (player.charge < player.maxCharge || player.specialCooldown > 0) return;
            
            player.isUsingSpecial = true;
            player.charge = 0;
            player.specialCooldown = 180; // 3 seconds at 60fps
            
            // Send to server if online
            if (isOnlineMode && socket) {
                socket.emit('specialAttack', {
                    roomId: roomId,
                    attackType: selectedCharacter.specialAttack
                });
            }
            
            switch(selectedCharacter.specialAttack) {
                case 'groundSlam':
                    groundSlam();
                    break;
                case 'shadowDash':
                    shadowDash();
                    break;
                case 'multiShot':
                    multiShot();
                    break;
                case 'timeField':
                    timeField();
                    break;
                case 'uppercut':
                    uppercut();
                    break;
                case 'laserBeam':
                    laserBeam();
                    break;
            }
            
            setTimeout(() => {
                player.isUsingSpecial = false;
            }, 500);
        }
        
        function executeSpecialAttack(attackType, target) {
            switch(attackType) {
                case 'groundSlam':
                    executeGroundSlam(target);
                    break;
                case 'shadowDash':
                    executeShadowDash(target);
                    break;
                case 'multiShot':
                    executeMultiShot(target);
                    break;
                case 'timeField':
                    executeTimeField(target);
                    break;
                case 'uppercut':
                    executeUppercut(target);
                    break;
                case 'laserBeam':
                    executeLaserBeam(target);
                    break;
            }
        }
        
        function groundSlam() {
            // Create shockwave effect
            for (let i = 0; i < 30; i++) {
                particles.push(createParticle(player.x + player.width/2, player.y + player.height, 'death'));
            }
            
            // Damage all enemies in range
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive !== false) {
                    const distance = Math.abs(target.x - player.x);
                    if (distance < 150) {
                        target.health -= 40;
                        target.velocityY = -15; // Launch enemies
                        if (target.health <= 0) {
                            if (isOnlineMode) {
                                target.alive = false;
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                endGame('You Win!', 'Congratulations! You defeated your opponent!');
                            } else {
                                target.alive = false;
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            }
                        }
                    }
                }
            });
        }
        
        function executeGroundSlam(target) {
            // Create shockwave effect
            for (let i = 0; i < 30; i++) {
                particles.push(createParticle(target.x + target.width/2, target.y + target.height, 'death'));
            }
            
            // Damage player
            const distance = Math.abs(player.x - target.x);
            if (distance < 150) {
                player.health -= 40;
                player.velocityY = -15;
                if (player.health <= 0) {
                    endGame('You Lose!', 'Your opponent defeated you!');
                }
            }
        }
        
        function shadowDash() {
            const dashDistance = player.facing === 'right' ? 200 : -200;
            const startX = player.x;
            const endX = player.x + dashDistance;
            
            // Create shadow trail
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const trailX = startX + (dashDistance * i / 10);
                    for (let j = 0; j < 5; j++) {
                        particles.push(createParticle(trailX + player.width/2, player.y + player.height/2, 'spawn'));
                    }
                }, i * 20);
            }
            
            // Teleport and damage enemies along the path
            player.x = endX;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive !== false && 
                    ((player.facing === 'right' && target.x > startX && target.x < endX) ||
                     (player.facing === 'left' && target.x < startX && target.x > endX))) {
                    target.health -= 30;
                    if (target.health <= 0) {
                        if (isOnlineMode) {
                            target.alive = false;
                            createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            endGame('You Win!', 'Congratulations! You defeated your opponent!');
                        } else {
                            target.alive = false;
                            createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                        }
                    }
                }
            });
        }
        
        function executeShadowDash(target) {
            const dashDistance = target.facing === 'right' ? 200 : -200;
            const startX = target.x;
            const endX = target.x + dashDistance;
            
            // Create shadow trail
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const trailX = startX + (dashDistance * i / 10);
                    for (let j = 0; j < 5; j++) {
                        particles.push(createParticle(trailX + target.width/2, target.y + target.height/2, 'spawn'));
                    }
                }, i * 20);
            }
            
            // Damage player if in path
            if ((target.facing === 'right' && player.x > startX && player.x < endX) ||
                (target.facing === 'left' && player.x < startX && player.x > endX)) {
                player.health -= 30;
                if (player.health <= 0) {
                    endGame('You Lose!', 'Your opponent defeated you!');
                }
            }
        }
        
        function multiShot() {
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const projectile = {
                    x: player.x + player.width/2,
                    y: player.y + 20,
                    velocityX: Math.cos(rad) * 8,
                    velocityY: Math.sin(rad) * 8,
                    life: 60,
                    damage: 25
                };
                
                // Animate projectile
                const animateProjectile = () => {
                    if (projectile.life <= 0) return;
                    
                    projectile.x += projectile.velocityX;
                    projectile.y += projectile.velocityY;
                    projectile.life--;
                    
                    // Draw projectile
                    ctx.save();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Check collision with targets
                    const targets = isOnlineMode ? [player2] : enemies;
                    targets.forEach(target => {
                        if (target.alive !== false) {
                            const distance = Math.sqrt(
                                Math.pow(target.x + target.width/2 - projectile.x, 2) + 
                                Math.pow(target.y + target.height/2 - projectile.y, 2)
                            );
                            if (distance < 20) {
                                target.health -= projectile.damage;
                                if (target.health <= 0) {
                                    if (isOnlineMode) {
                                        target.alive = false;
                                        createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                        endGame('You Win!', 'Congratulations! You defeated your opponent!');
                                    } else {
                                        target.alive = false;
                                        createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                    }
                                }
                                projectile.life = 0;
                            }
                        }
                    });
                    
                    if (projectile.life > 0) {
                        requestAnimationFrame(animateProjectile);
                    }
                };
                
                setTimeout(() => animateProjectile(), angle * 10);
            });
        }
        
        function executeMultiShot(target) {
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const projectile = {
                    x: target.x + target.width/2,
                    y: target.y + 20,
                    velocityX: Math.cos(rad) * 8,
                    velocityY: Math.sin(rad) * 8,
                    life: 60,
                    damage: 25
                };
                
                // Animate projectile
                const animateProjectile = () => {
                    if (projectile.life <= 0) return;
                    
                    projectile.x += projectile.velocityX;
                    projectile.y += projectile.velocityY;
                    projectile.life--;
                    
                    // Draw projectile
                    ctx.save();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Check collision with player
                    const distance = Math.sqrt(
                        Math.pow(player.x + player.width/2 - projectile.x, 2) + 
                        Math.pow(player.y + player.height/2 - projectile.y, 2)
                    );
                    if (distance < 20) {
                        player.health -= projectile.damage;
                        if (player.health <= 0) {
                            endGame('You Lose!', 'Your opponent defeated you!');
                        }
                        projectile.life = 0;
                    }
                    
                    if (projectile.life > 0) {
                        requestAnimationFrame(animateProjectile);
                    }
                };
                
                setTimeout(() => animateProjectile(), angle * 10);
            });
        }
        
        function timeField() {
            // Create time field effect
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = player.x + player.width/2 + Math.cos(angle) * 100;
                const y = player.y + player.height/2 + Math.sin(angle) * 100;
                particles.push(createParticle(x, y, 'spawn'));
            }
            
            // Slow all enemies
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive !== false) {
                    target.slowed = true;
                    target.slowTimer = 300; // 5 seconds
                    target.speed *= 0.3;
                }
            });
        }
        
        function executeTimeField(target) {
            // Create time field effect
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = target.x + target.width/2 + Math.cos(angle) * 100;
                const y = target.y + target.height/2 + Math.sin(angle) * 100;
                particles.push(createParticle(x, y, 'spawn'));
            }
            
            // Slow player
            player.slowed = true;
            player.slowTimer = 300;
            player.speed *= 0.3;
        }
        
        function uppercut() {
            // Create upward effect
            for (let i = 0; i < 15; i++) {
                particles.push(createParticle(player.x + player.width/2, player.y, 'spawn'));
            }
            
            // Damage and launch nearby enemies
            const targets = isOnlineMode ? [player2] : enemies;
            targets.forEach(target => {
                if (target.alive !== false) {
                    const distance = Math.abs(target.x - player.x);
                    if (distance < 80) {
                        target.health -= 35;
                        target.velocityY = -20; // Strong launch
                        target.velocityX = (target.x < player.x ? -10 : 10);
                        if (target.health <= 0) {
                            if (isOnlineMode) {
                                target.alive = false;
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                endGame('You Win!', 'Congratulations! You defeated your opponent!');
                            } else {
                                target.alive = false;
                                createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                            }
                        }
                    }
                }
            });
        }
        
        function executeUppercut(target) {
            // Create upward effect
            for (let i = 0; i < 15; i++) {
                particles.push(createParticle(target.x + target.width/2, target.y, 'spawn'));
            }
            
            // Damage and launch player
            const distance = Math.abs(player.x - target.x);
            if (distance < 80) {
                player.health -= 35;
                player.velocityY = -20;
                player.velocityX = (player.x < target.x ? -10 : 10);
                if (player.health <= 0) {
                    endGame('You Lose!', 'Your opponent defeated you!');
                }
            }
        }
        
        function laserBeam() {
            const beamWidth = 20;
            const beamLength = canvas.width;
            const startX = player.facing === 'right' ? player.x + player.width : player.x;
            const endX = player.facing === 'right' ? canvas.width : 0;
            
            // Animate laser sweep
            let sweepProgress = 0;
            const sweepSpeed = 0.05;
            
            const animateLaser = () => {
                if (sweepProgress >= 1) return;
                
                sweepProgress += sweepSpeed;
                
                // Draw laser
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(startX, player.y + 20, (endX - startX) * sweepProgress, beamWidth);
                ctx.restore();
                
                // Create laser particles
                for (let i = 0; i < 3; i++) {
                    const x = startX + (endX - startX) * sweepProgress;
                    const y = player.y + 20 + Math.random() * beamWidth;
                    particles.push(createParticle(x, y, 'death'));
                }
                
                // Check collision with targets
                const targets = isOnlineMode ? [player2] : enemies;
                targets.forEach(target => {
                    if (target.alive !== false) {
                        const targetCenterX = target.x + target.width/2;
                        const targetCenterY = target.y + target.height/2;
                        if (targetCenterX >= startX && targetCenterX <= startX + (endX - startX) * sweepProgress &&
                            targetCenterY >= player.y + 20 && targetCenterY <= player.y + 20 + beamWidth) {
                            target.health -= 2; // Continuous damage
                            if (target.health <= 0) {
                                if (isOnlineMode) {
                                    target.alive = false;
                                    createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                    endGame('You Win!', 'Congratulations! You defeated your opponent!');
                                } else {
                                    target.alive = false;
                                    createDeathEffect(target.x + target.width/2, target.y + target.height/2);
                                }
                            }
                        }
                    }
                });
                
                requestAnimationFrame(animateLaser);
            };
            
            animateLaser();
        }
        
        function executeLaserBeam(target) {
            const beamWidth = 20;
            const beamLength = canvas.width;
            const startX = target.facing === 'right' ? target.x + target.width : target.x;
            const endX = target.facing === 'right' ? canvas.width : 0;
            
            // Animate laser sweep
            let sweepProgress = 0;
            const sweepSpeed = 0.05;
            
            const animateLaser = () => {
                if (sweepProgress >= 1) return;
                
                sweepProgress += sweepSpeed;
                
                // Draw laser
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(startX, target.y + 20, (endX - startX) * sweepProgress, beamWidth);
                ctx.restore();
                
                // Create laser particles
                for (let i = 0; i < 3; i++) {
                    const x = startX + (endX - startX) * sweepProgress;
                    const y = target.y + 20 + Math.random() * beamWidth;
                    particles.push(createParticle(x, y, 'death'));
                }
                
                // Check collision with player
                const playerCenterX = player.x + player.width/2;
                const playerCenterY = player.y + player.height/2;
                if (playerCenterX >= startX && playerCenterX <= startX + (endX - startX) * sweepProgress &&
                    playerCenterY >= target.y + 20 && playerCenterY <= target.y + 20 + beamWidth) {
                    player.health -= 2; // Continuous damage
                    if (player.health <= 0) {
                        endGame('You Lose!', 'Your opponent defeated you!');
                    }
                }
                
                requestAnimationFrame(animateLaser);
            };
            
            animateLaser();
        }
        
        // Update functions
        function updatePlayer() {
            if (isRespawning) return;
            
            // Movement
            if (keys['a']) {
                player.velocityX = -player.speed;
                player.facing = 'left';
            } else if (keys['d']) {
                player.velocityX = player.speed;
                player.facing = 'right';
            } else {
                player.velocityX *= 0.8;
            }
            
            // Jump
            if (keys['w'] && player.y >= groundY) {
                player.velocityY = -player.jumpPower;
            }
            
            // Special attack
            if (keys['q']) {
                useSpecialAttack();
            }
            
            // Attacks
            if (player.attackCooldown <= 0) {
                if (keys[' ']) {
                    player.isAttacking = true;
                    player.attackType = 'punch';
                    player.attackCooldown = 30;
                    player.attackFrame = 0;
                    // Add charge (1.5x rate)
                    if (player.charge < player.maxCharge) {
                        player.charge += 15;
                    }
                    // Check collision with all targets
                    const targets = isOnlineMode ? [player2] : enemies;
                    targets.forEach(target => {
                        if (target.alive !== false) {
                            checkAttackCollision(player, target, 15 * player.damageMultiplier);
                        }
                    });
                } else if (keys['f']) {
                    player.isAttacking = true;
                    player.attackType = 'kick';
                    player.attackCooldown = 40;
                    player.attackFrame = 0;
                    // Add charge (1.5x rate)
                    if (player.charge < player.maxCharge) {
                        player.charge += 23;
                    }
                    // Check collision with all targets
                    const targets = isOnlineMode ? [player2] : enemies;
                    targets.forEach(target => {
                        if (target.alive !== false) {
                            checkAttackCollision(player, target, 20 * player.damageMultiplier);
                        }
                    });
                }
            } else {
                player.attackCooldown--;
                player.attackFrame++;
                if (player.attackCooldown <= 20) {
                    player.isAttacking = false;
                    player.attackType = null;
                }
            }
            
            // Update special cooldown
            if (player.specialCooldown > 0) {
                player.specialCooldown--;
            }
            
            // Physics
            player.velocityY += gravity;
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Boundaries
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y > groundY) {
                player.y = groundY;
                player.velocityY = 0;
            }
            
            // Send game state to server if online
            if (isOnlineMode && socket) {
                socket.emit('gameState', {
                    roomId: roomId,
                    x: player.x,
                    y: player.y,
                    velocityX: player.velocityX,
                    velocityY: player.velocityY,
                    facing: player.facing,
                    isAttacking: player.isAttacking,
                    attackType: player.attackType,
                    health: player.health,
                    isUsingSpecial: player.isUsingSpecial
                });
            }
        }
        
        function updateEnemy(enemy) {
            if (!enemy.alive) return;
            
            // Update slow effect
            if (enemy.slowed) {
                enemy.slowTimer--;
                if (enemy.slowTimer <= 0) {
                    enemy.slowed = false;
                    // Reset speed based on difficulty
                    if (gameMode === 'classic' && gameDifficulty === 'hard') {
                        enemy.speed = 4.5;
                    } else {
                        enemy.speed = 3;
                    }
                }
            }
            
            // AI Decision Making
            if (enemy.aiCooldown <= 0) {
                const distance = Math.abs(player.x - enemy.x);
                enemy.aiDecision = Math.random();
                
                if (distance > 150) {
                    // Move towards player
                    if (player.x < enemy.x) {
                        enemy.velocityX = -enemy.speed;
                        enemy.facing = 'left';
                    } else {
                        enemy.velocityX = enemy.speed;
                        enemy.facing = 'right';
                    }
                } else if (distance < 80) {
                    // Move away if too close
                    if (player.x < enemy.x) {
                        enemy.velocityX = enemy.speed;
                        enemy.facing = 'right';
                    } else {
                        enemy.velocityX = -enemy.speed;
                        enemy.facing = 'left';
                    }
                } else {
                    enemy.velocityX *= 0.8;
                }
                
                // Attack decision
                if (distance < 100 && enemy.attackCooldown <= 0) {
                    if (enemy.aiDecision < 0.6) {
                        enemy.isAttacking = true;
                        enemy.attackType = 'punch';
                        enemy.attackCooldown = 35;
                        enemy.attackFrame = 0;
                        checkAttackCollision(enemy, player, 15 * (enemy.damageMultiplier || 1));
                    } else {
                        enemy.isAttacking = true;
                        enemy.attackType = 'kick';
                        enemy.attackCooldown = 45;
                        enemy.attackFrame = 0;
                        checkAttackCollision(enemy, player, 20 * (enemy.damageMultiplier || 1));
                    }
                }
                
                // Jump decision
                if (enemy.aiDecision < 0.1 && enemy.y >= groundY) {
                    enemy.velocityY = -enemy.jumpPower;
                }
                
                enemy.aiCooldown = 30;
            } else {
                enemy.aiCooldown--;
            }
            
            // Physics
            enemy.velocityY += gravity;
            enemy.x += enemy.velocityX;
            enemy.y += enemy.velocityY;
            
            // Boundaries
            if (enemy.x < 0) enemy.x = 0;
            if (enemy.x + enemy.width > canvas.width) enemy.x = canvas.width - enemy.width;
            if (enemy.y > groundY) {
                enemy.y = groundY;
                enemy.velocityY = 0;
            }
            
            // Attack cooldown
            if (enemy.attackCooldown > 0) {
                enemy.attackCooldown--;
                enemy.attackFrame++;
                if (enemy.attackCooldown <= 25) {
                    enemy.isAttacking = false;
                    enemy.attackType = null;
                }
            }
        }
        
        function checkAttackCollision(attacker, defender, damage) {
            const distance = Math.abs(attacker.x - defender.x);
            const range = attacker.attackRange || 60;
            if (distance < range && Math.abs(attacker.y - defender.y) < 50) {
                defender.health -= damage;
                defender.health = Math.max(0, defender.health);
                
                if (defender.health <= 0 && defender !== player && defender !== player2) {
                    defender.alive = false;
                    createDeathEffect(defender.x + defender.width/2, defender.y + defender.height/2);
                }
                
                updateHealthBars();
                
                // Knockback
                const knockback = attacker.facing === 'right' ? 10 : -10;
                defender.velocityX = knockback;
                defender.velocityY = -5;
            }
        }
        
        function updateHealthBars() {
            document.getElementById('playerHealth').style.width = 
                `${(player.health / player.maxHealth) * 100}%`;
            
            if (isOnlineMode) {
                document.getElementById('player2Health').style.width = 
                    `${(player2.health / player2.maxHealth) * 100}%`;
            } else if (gameMode === 'classic' && enemies.length > 0) {
                document.getElementById('cpuHealth').style.width = 
                    `${(enemies[0].health / enemies[0].maxHealth) * 100}%`;
            }
            
            // Update charge bar
            document.getElementById('chargeFill').style.width = 
                `${(player.charge / player.maxCharge) * 100}%`;
            
            // Update wave info
            if (gameMode === 'wave') {
                const aliveEnemies = enemies.filter(e => e.alive).length;
                document.getElementById('currentWave').textContent = currentWave;
                document.getElementById('enemiesLeft').textContent = aliveEnemies;
            }
        }
        
        function checkWaveComplete() {
            if (gameMode === 'wave') {
                const aliveEnemies = enemies.filter(e => e.alive).length;
                if (aliveEnemies === 0) {
                    // Wave complete, spawn next wave
                    currentWave++;
                    spawnWave();
                }
            }
        }
        
        function spawnWave() {
            enemies = [];
            for (let i = 0; i < currentWave; i++) {
                const x = 600 + (i * 80); // Spread enemies out
                enemies.push(createEnemy(x));
            }
        }
        
        function respawnPlayer() {
            isRespawning = true;
            playerLives--;
            
            // Update lives display
            updateLivesDisplay();
            
            if (playerLives <= 0) {
                endGame('Game Over', `You survived ${currentWave} wave${currentWave > 1 ? 's' : ''}!`);
                return;
            }
            
            // Reset player
            player.health = player.maxHealth;
            player.x = 100;
            player.y = groundY;
            player.velocityX = 0;
            player.velocityY = 0;
            
            // Create spawn effect
            createSpawnEffect(player.x + player.width/2, player.y + player.height/2);
            
            // Temporary invincibility
            setTimeout(() => {
                isRespawning = false;
            }, 2000);
        }
        
        function updateLivesDisplay() {
            const livesContainer = document.getElementById('livesContainer');
            livesContainer.innerHTML = '';
            for (let i = 0; i < playerLives; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                livesContainer.appendChild(life);
            }
        }
        
        function checkGameOver() {
            if (player.health <= 0) {
                if (gameMode === 'wave' && playerLives > 0) {
                    respawnPlayer();
                } else {
                    let message = '';
                    if (gameMode === 'classic') {
                        message = gameDifficulty === 'hard' ? 'The Hard CPU was too strong!' : 'The CPU was too strong this time.';
                    } else if (isOnlineMode) {
                        message = 'You lost the match!';
                    } else {
                        message = `You survived ${currentWave} wave${currentWave > 1 ? 's' : ''}!`;
                    }
                    endGame('Game Over', message);
                }
            } else if (gameMode === 'classic' && enemies.length > 0 && enemies[0].health <= 0) {
                endGame('You Win!', 'Congratulations! You defeated the CPU!');
            }
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, groundY + 60, canvas.width, 40);
            
            // Update and draw player
            updatePlayer();
            drawStickman(player, 'Player');
            
            // Update and draw player 2 or enemies
            if (isOnlineMode) {
                drawStickman(player2, 'Player 2');
            } else {
                enemies.forEach(enemy => {
                    updateEnemy(enemy);
                    if (enemy.alive) {
                        drawStickman(enemy, 'Enemy');
                        // Draw health bars only in wave mode
                        if (gameMode === 'wave') {
                            drawEnemyHealthBar(enemy);
                        }
                    }
                });
            }
            
            // Draw particles
            drawParticles();
            
            // Check wave completion
            checkWaveComplete();
            
            // Check game over
            checkGameOver();
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        function startGame(mode, difficulty = 'normal') {
            gameMode = mode;
            gameDifficulty = difficulty;
            isOnlineMode = false;
            
            if (mode === 'classic') {
                document.getElementById('difficultySelection').style.display = 'none';
            } else {
                document.getElementById('modeSelection').style.display = 'none';
            }
            
            gameRunning = true;
            
            // Reset game state
            playerLives = 3;
            currentWave = 1;
            particles = [];
            
            // Setup UI based on mode
            if (mode === 'classic') {
                document.getElementById('waveInfo').style.display = 'none';
                document.getElementById('cpuHealthContainer').style.display = 'flex';
                document.getElementById('player2Info').style.display = 'none';
                enemies = [createEnemy(600, difficulty)];
            } else {
                document.getElementById('waveInfo').style.display = 'flex';
                document.getElementById('cpuHealthContainer').style.display = 'none';
                document.getElementById('player2Info').style.display = 'none';
                updateLivesDisplay();
                spawnWave();
            }
            
            // Apply selected character stats to player
            player.color = selectedCharacter.color;
            player.accessories = selectedCharacter.accessories;
            player.speed = selectedCharacter.stats.speed;
            player.health = selectedCharacter.stats.health;
            player.maxHealth = selectedCharacter.stats.health;
            player.damageMultiplier = selectedCharacter.stats.damage;
            player.attackRange = selectedCharacter.stats.range;
            player.charge = 0;
            player.specialCooldown = 0;
            
            // Reset player position
            player.x = 100;
            player.y = groundY;
            player.velocityX = 0;
            player.velocityY = 0;
            player.isAttacking = false;
            player.attackType = null;
            player.attackCooldown = 0;
            player.attackFrame = 0;
            isRespawning = false;
            
            updateHealthBars();
            gameLoop();
        }
        
        function startOnlineGame() {
            gameMode = 'online';
            isOnlineMode = true;
            gameRunning = true;
            
            // Reset game state
            particles = [];
            
            // Setup UI for online mode
            document.getElementById('waveInfo').style.display = 'none';
            document.getElementById('cpuHealthContainer').style.display = 'none';
            document.getElementById('player2Info').style.display = 'flex';
            
            // Apply selected character stats to player
            player.color = selectedCharacter.color;
            player.accessories = selectedCharacter.accessories;
            player.speed = selectedCharacter.stats.speed;
            player.health = selectedCharacter.stats.health;
            player.maxHealth = selectedCharacter.stats.health;
            player.damageMultiplier = selectedCharacter.stats.damage;
            player.attackRange = selectedCharacter.stats.range;
            player.charge = 0;
            player.specialCooldown = 0;
            
            // Reset player position
            player.x = isPlayer1 ? 100 : 600;
            player.y = groundY;
            player.velocityX = 0;
            player.velocityY = 0;
            player.isAttacking = false;
            player.attackType = null;
            player.attackCooldown = 0;
            player.attackFrame = 0;
            player.facing = isPlayer1 ? 'right' : 'left';
            isRespawning = false;
            
            // Initialize player 2
            player2.health = 100;
            player2.maxHealth = 100;
            player2.x = isPlayer1 ? 600 : 100;
            player2.y = groundY;
            player2.facing = isPlayer1 ? 'left' : 'right';
            
            updateHealthBars();
            gameLoop();
        }
        
        function endGame(title, message) {
            gameRunning = false;
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            cancelAnimationFrame(animationId);
            document.getElementById('gameOverText').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOver').style.display = 'block';
            updateConnectionStatus(false);
        }
        
        // Initialize health bars
        updateHealthBars();
    </script>
</body>
</html>
